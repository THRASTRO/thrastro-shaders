/* autogenerated by webmerge (join context) */
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

if (!window.THRAPP) {
  window.THRAPP = {};
}

// ######################################################################
// Base class Implementation for all of our custom shaders.
// ######################################################################

// private scope
(function (THREE, THRAPP) {
  "use strict";

  // ######################################################################
  // ######################################################################
  // Function to create a mixin class
  class CustomRawShader extends THREE.RawShaderMaterial {
    constructor(parameters) {
      parameters = parameters || {};
      parameters.glslVersion = "300 es";
      super(parameters);
    }
  }

  // ######################################################################
  // ######################################################################
  // Helper class for materials depending on mesh
  // E.g. we get world position or radius from it
  class Mesh extends THREE.Mesh {
    constructor(geometry, material) {
      super(geometry, material);
      material.pbody = this;
    }
  }

  // ######################################################################
  // ######################################################################

  // helper for shader chunk manipulation
  function insertChunk(chunks, idx, chunk, replace) {
    var insert = chunk.shader || "",
      replace = replace ? 1 : 0;
    if (Array.isArray(insert)) insert = insert.join("\n");
    return chunks.splice(idx, replace, insert);
  }
  // EO insertChunk

  // helper for shader chunk manipulation
  function insertChunks(inserts, chunks) {
    if (!inserts || !inserts.length) return;
    for (var i = 0; i < inserts.length; i++) {
      var found = false,
        chunk = inserts[i];
      for (var n = 0; n < chunks.length; n++) {
        if (chunk.after && chunk.after.test(chunks[n])) {
          insertChunk(chunks, n + 1, chunk, false);
          n += 2; // skip added
          found = true;
        } else if (chunk.before && chunk.before.test(chunks[n])) {
          insertChunk(chunks, n, chunk, false);
          n += 2; // skip added
          found = true;
        } else if (chunk.replace && chunk.replace.test(chunks[n])) {
          insertChunk(chunks, n, chunk, true);
          n += 1; // skip added
          found = true;
        }
      }
      // this only happens if source changed or dev error
      if (!found) throw Error("Shader Chunk not found");
    }
  }
  // EO insertChunks

  // ######################################################################
  // ######################################################################

  const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  // Helper to replace include occurrence
  function includeReplacer(match, include) {
    const string = THREE.ShaderChunk[include];

    if (string === undefined) {
      throw new Error("Can not resolve #include <" + include + ">");
    }

    // Recursively resolve includes
    return resolveIncludes(string);
  }
  // EO includeReplacer

  // Entry function to resolve includes
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  // EO resolveIncludes

  // ######################################################################
  // ######################################################################

  THREE.ShaderLib.none = {
    uniforms: {},
    vertexShader: '',
    fragmentShader: '',
  };

  // Function to create a mixin class
  function CustomMaterial(SuperClass, typename, lib) {
    class CustomMaterial extends SuperClass {
      constructor(parameters) {
        parameters = parameters || {};
        super(parameters);
        this.type = typename;
        var base = THREE.ShaderLib[lib];
        this.defines = this.defines || [];
        // Create a copy of the base vertex shader
        var shaderVerts = base.vertexShader.split(/\n+/);
        insertChunks(this.getVertexChunks(), shaderVerts);
        // Create a copy of the base fragment shader
        var shaderFrags = base.fragmentShader.split(/\n+/);
        insertChunks(this.getFragmentChunks(), shaderFrags);
        // Assign the shaders by going through overloadable methods
        this.vertexShader = this.getVertexShader(shaderVerts.join("\n"));
        this.fragmentShader = this.getFragmentShader(shaderFrags.join("\n"));

        // Resolve includes to extend shader sub-chunks
        this.vertexShader = resolveIncludes(this.vertexShader);
        this.fragmentShader = resolveIncludes(this.fragmentShader);

        // Create a copy of the base vertex shader
        var shaderSubVerts = this.vertexShader.split(/\n+/);
        insertChunks(this.getVertexSubChunks(), shaderSubVerts);
        // Create a copy of the base fragment shader
        var shaderSubFrags = this.fragmentShader.split(/\n+/);
        insertChunks(this.getFragmentSubChunks(), shaderSubFrags);

        // Create the final joined snippets to compile
        this.vertexShader = shaderSubVerts.join("\n");
        this.fragmentShader = shaderSubFrags.join("\n");

        // Merge uniforms passed by parameters with the base material uniforms
        this.uniforms = THREE.UniformsUtils.merge([
          parameters.uniforms,
          base.uniforms,
        ]);

        // Add uniforms for specializations
        this.addUniforms(this.uniforms);
        // Set the material parameters
        this.setValues(parameters);
      }
      // EO constructor

      // Set defines during setup
      setDefines(defines) {
        for (var key in defines) {
          this.defines[key] = defines[key];
        }
      }
      // EO constructor

      // Overload to alter shader-code
      getFragmentShader(shader) {
        return shader;
      }
      // EO getFragmentShader

      // Overload to alter shader-code
      getVertexShader(shader) {
        return shader;
      }
      // EO getVertexShader

      // Overload to add chunks
      getVertexChunks() {
        return [];
      }
      // EO getVertexChunks

      // Overload to add chunks
      getFragmentChunks() {
        return [];
      }
      // EO getFragmentChunks

      // Overload to add chunks
      getVertexSubChunks() {
        return [];
      }
      // EO getVertexSubChunks

      // Overload to add chunks
      getFragmentSubChunks() {
        return [];
      }
      // EO getFragmentSubChunks

      // Method to add uniforms during setup
      addUniforms(uniforms) { }

      // Called during render to update stuff
      updateUniforms() { }
    }

    // Return mixed in class
    return CustomMaterial;
  }

  // ######################################################################
  // ######################################################################

  // assign class to global namespace
  THRAPP.CustomMaterial = CustomMaterial;

  // ######################################################################
  // ######################################################################

  class CustomShaderMaterial extends CustomMaterial(
    THREE.ShaderMaterial,
    "CustomShaderMaterial",
    "basic"
  ) {
    constructor(parameters) {
      super(parameters);
    }
  }

  class CustomMeshBasicMaterial extends CustomMaterial(
    THREE.MeshBasicMaterial,
    "CustomMeshBasicMaterial",
    "basic"
  ) {
    constructor(parameters) {
      super(parameters);
    }
  }

  class CustomMeshLambertMaterial extends CustomMaterial(
    THREE.MeshLambertMaterial,
    "CustomMeshLambertMaterial",
    "lambert"
  ) {
    constructor(parameters) {
      super(parameters);
    }
  }

  class CustomMeshPhongMaterial extends CustomMaterial(
    THREE.MeshPhongMaterial,
    "CustomMeshPhongMaterial",
    "phong"
  ) {
    constructor(parameters) {
      super(parameters);
    }
  }

  class CustomMeshPhysicalMaterial extends CustomMaterial(
    THREE.MeshPhysicalMaterial,
    "CustomMeshPhysicalMaterial",
    "physical"
  ) {
    constructor(parameters) {
      super(parameters);
    }
  }

  // ######################################################################
  // ######################################################################

  // Small helper class
  THRAPP.Mesh = Mesh;

  // assign class to global namespace
  THRAPP.CustomRawShader = CustomRawShader;
  THRAPP.CustomShaderMaterial = CustomShaderMaterial;
  THRAPP.CustomMeshBasicMaterial = CustomMeshBasicMaterial;
  THRAPP.CustomMeshLambertMaterial = CustomMeshLambertMaterial;
  THRAPP.CustomMeshPhongMaterial = CustomMeshPhongMaterial;
  THRAPP.CustomMeshPhysicalMaterial = CustomMeshPhysicalMaterial;

  // ######################################################################
  // ######################################################################

  THRAPP.StartStaticForLoop = function (name, len) {
    return [
      `#if ${len} > 0`,
      `#if ${len} > 1`,
      `  for ( int ${name} = 0; ${name} < ${len}; ++ ${name} ) {`,
      "#else",
      `  { int ${name} = 0;`,
      "#endif",
      "",
    ].join("\n");
  }

  THRAPP.EndStaticForLoop = function (name, len) {
    return [
      "  }",
      "#endif",
      "",
    ].join("\n");
  }

  // ######################################################################
  // ######################################################################
})(THREE, THRAPP);
// EO private scope
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

if (!window.THRAPP) {
    window.THRAPP = {};
}

// private scope
(function (THREE, THRAPP) {
    "use strict";

    class ConstellationsShader extends THRAPP.CustomRawShader {

        constructor(parameters) {
            parameters = parameters || {};
            super(parameters);
            this.isRawShaderMaterial = false;
            this.uniforms.time = { type: 'f', value: parameters.time || 0.0 };
            this.uniforms.scale = { type: 'f', value: parameters.scale || 1.0 };
            this.uniforms.opacity = { type: 'f', value: parameters.opacity || 1.0 };
            this.uniforms.camFadeDist = { type: 'f', value: parameters.camFadeDist || 5e9 };
            this.uniforms.color = { type: 'v3', value: new THREE.Color(parameters.color || 0xffffff) };
            // Declare full vertex shader
            this.vertexShader = [
                // Include threejs chunks
                "#include <common>",
                "#include <logdepthbuf_pars_vertex>",
                // Local uniforms
                "uniform float time;",
                "uniform float scale;",
                "uniform float opacity;",
                "uniform float camFadeDist;",
                "uniform vec3 color;",
                // Local attributes
                "attribute vec2 attributes;",
                // Local variable
                "varying vec4 fragColor;",
                // The main shader program
                "void main() {",
                [
                    // Positional arguments
                    " float ra = position.x;",
                    " float dec = position.y;",
                    " float dist = position.z;",
                    // Movement arguments
                    " float pm_ra = attributes.x;",
                    " float pm_dec = attributes.y;",
                    // time is in julian years
                    // movement is rads per year
                    // hyg pmrarad/decrad (25,26)
                    " ra += pm_ra * time / 206300000.0;",
                    " dec += pm_dec * time / 206300000.0;",
                    // Convert from spherical coordinates
                    " float x = cos(dec) * cos(ra) * dist * scale;",
                    " float y = cos(dec) * sin(ra) * dist * scale;",
                    " float z = sin(dec) * dist * scale;",
                    " vec4 pos = vec4(x, y, z, 1.0);",
                    // Calculate the final position
                    " gl_Position = projectionMatrix * modelViewMatrix * pos;",
                    // hide lines when camera moves away from center"
                    " float camdist = length(cameraPosition.xyz);",
                    // smooth the fade out between min and max distance"
                    " float alpha = 1.0 - smoothstep(0.0, camFadeDist, camdist);",
                    // Calculate the final fragment color
                    "fragColor = vec4(color.xyz, alpha * opacity);",
                    // THREE.ShaderChunk[ 'logdepthbuf_vertex'
                    "#include <logdepthbuf_vertex>",
                ].join("\n"),
                "}",
            ].join("\n");
            // Declare full fragment shader
            this.fragmentShader = [
                // Include threejs chunks
                "#include <common>",
                "#include <logdepthbuf_pars_fragment>",
                // Required since we use GLSL3
                "out highp vec4 pc_fragColor;",
                "#define gl_FragColor pc_fragColor",
                // Local variable
                "varying vec4 fragColor;",
                // Main fragment shader
                "void main() {",
                [
                    // Set the final color
                    " gl_FragColor = fragColor;",
                    // THREE.ShaderChunk[ 'logdepthbuf_fragment'
                    " #include <logdepthbuf_fragment>",
                ].join("\n"),
                "}",
            ].join("\n");
            // Hookup optional dat.gui
            if (!parameters.datgui) return;
            var gui = parameters.datgui;
            var uniforms = this.uniforms;
            if (parameters.name) gui = gui.addFolder(parameters.name)
            gui.add(uniforms.scale, 'value', 0, 9).step(0.001).name('scale');
            gui.add(uniforms.opacity, 'value', 0, 1).step(0.001).name('opacity');
            gui.add(uniforms.camFadeDist, 'value', 0, 5e6).step(0.001).name('fade dist');
            gui.addThreeColor(uniforms.color, 'value').name('color');
        }
        // EO constructor
    }

    // ######################################################################
    // ######################################################################

    ConstellationsShader.prototype.time = null;
    ConstellationsShader.prototype.scale = null;
    ConstellationsShader.prototype.opacity = null;
    ConstellationsShader.prototype.color = null;
    ConstellationsShader.prototype.cameraFadeMin = null;
    ConstellationsShader.prototype.cameraFadeMax = null;

    // assign class to global namespace
    THRAPP.ConstellationsShader = ConstellationsShader;

    // ######################################################################
    // ######################################################################
})(THREE, THRAPP);
  // EO private scope
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

if (!window.THRAPP) {
    window.THRAPP = {};
}

// private scope
(function (THREE, THRAPP) {
    "use strict";

    class FirmamentShader extends THRAPP.CustomRawShader {

        constructor(parameters) {
            parameters = parameters || {};
            super(parameters);
            this.isRawShaderMaterial = false;
            this.defaultAttributeValues = [];
            this.uniforms.fov = { type: 'f', value: parameters.fov || 75.0 };
            this.uniforms.time = { type: 'f', value: parameters.time || 0.0 };
            this.uniforms.scale = { type: 'f', value: parameters.scale || 1.0 };
            this.uniforms.minMag = { type: 'f', value: parameters.minMag || -12.0 };
            this.uniforms.maxMag = { type: 'f', value: parameters.maxMag || 28.0 };
            this.uniforms.dimming = { type: 'f', value: parameters.dimming || 0.9 };
            this.uniforms.opacity = { type: 'f', value: parameters.opacity || 1.0 };
            this.uniforms.magFact = { type: 'f', value: parameters.magFact || 25.0 };
            this.uniforms.magScale = { type: 'f', value: parameters.magScale || 0.35 };
            this.uniforms.sizeScale = { type: 'f', value: parameters.sizeScale || 1.0 };
            this.uniforms.fillFactor = { type: 'f', value: parameters.fillFactor || 1.0 };
            this.uniforms.fillPower = { type: 'f', value: parameters.fillPower || 1.0 };
            this.uniforms.falloff = { type: 'f', value: parameters.falloff || 206264.80748432202 };

            this.vertexShader = [
                // Include threejs chunks
                "#include <common>",
                "#include <logdepthbuf_pars_vertex>",
                // Local uniforms
                "uniform float scale;",
                "uniform float minMag;",
                "uniform float maxMag;",
                "uniform float opacity;",
                "uniform float magFact;",
                "uniform float magScale;",
                "uniform float sizeScale;",
                // "uniform float fillFactor;",
                // "uniform float fillPower;",
                "uniform float falloff;",
                "uniform float dimming;",
                // Render state uniforms
                "uniform float fov;",
                "uniform float time;",
                // Local attributes
                "attribute vec4 attributes;",
                // Local variable
                "varying vec4 fragColor;",
                "varying float camStarDist;",
                // Helper function for log10 
                "float log10( in float n )",
                "{",
                "    // calculate log2 to log10",
                "    // kLogBase10 = 1.0 / log( 10.0 );",
                "    return log( n ) * 0.43429448190325176;",
                "}",
                // Helper to get star color from BV
                // RGB <0,1> <- BV <-0.4,+2.0> [-]
                "vec4 bv2rgb(float bv, float mag)",
                "{",
                "    float t;",
                "    float r = 0.0;",
                "    float g = 0.0;",
                "    float b = 0.0;",
                "    if (bv<-0.4) bv=-0.4;",
                "    if (bv> 1.95) bv= 1.95;",
                "    // http://www.vendian.org/mncharity/dir3/starcolor/details.html",
                "         if ((bv>=-0.40)&&(bv<0.00)) { t=(bv+0.40)/(0.00+0.40); r=0.61+(0.11*t)+(0.1*t*t); }",
                "    else if ((bv>= 0.00)&&(bv<0.40)) { t=(bv-0.00)/(0.40-0.00); r=0.83+(0.17*t)          ; }",
                "    else if ((bv>= 0.40)&&(bv<2.10)) { t=(bv-0.40)/(2.10-0.40); r=1.00                   ; }",
                "         if ((bv>=-0.40)&&(bv<0.00)) { t=(bv+0.40)/(0.00+0.40); g=0.70+(0.07*t)+(0.1*t*t); }",
                "    else if ((bv>= 0.00)&&(bv<0.40)) { t=(bv-0.00)/(0.40-0.00); g=0.87+(0.11*t)          ; }",
                "    else if ((bv>= 0.40)&&(bv<1.60)) { t=(bv-0.40)/(1.60-0.40); g=0.98-(0.16*t)          ; }",
                "    else if ((bv>= 1.60)&&(bv<2.00)) { t=(bv-1.60)/(2.00-1.60); g=0.82         -(0.5*t*t); }",
                "         if ((bv>=-0.40)&&(bv<0.40)) { t=(bv+0.40)/(0.40+0.40); b=1.00                   ; }",
                "    else if ((bv>= 0.40)&&(bv<1.50)) { t=(bv-0.40)/(1.50-0.40); b=1.00-(0.47*t)+(0.1*t*t); }",
                "    else if ((bv>= 1.50)&&(bv<1.94)) { t=(bv-1.50)/(1.94-1.50); b=0.63         -(0.6*t*t); }",
                "    return vec4(r, g, b, mag);",
                "}",
                // Main vertex shader
                "void main() {",
                [
                    // Positional arguments
                    " float ra = position.x;",
                    " float dec = position.y;",
                    " float dist = position.z;",
                    // Movement arguments
                    " float pm_ra = attributes.x;",
                    " float pm_dec = attributes.y;",
                    // time is in julian years
                    // movement is rads per year
                    // hyg pmrarad/decrad (25,26)
                    " ra += pm_ra * time / 206300000.0;",
                    " dec += pm_dec * time / 206300000.0;",
                    // Convert from spherical coordinates
                    " float x = cos(dec) * cos(ra) * dist * scale;",
                    " float y = cos(dec) * sin(ra) * dist * scale;",
                    " float z = sin(dec) * dist * scale;",
                    " vec4 pos = vec4(x, y, z, 1.0);",
                    // Calculate the final position
                    " gl_Position = projectionMatrix * modelViewMatrix * pos;",
                    // Get star color from BV attribute
                    " fragColor = bv2rgb(attributes.a, dimming);",
                    // the camera distance can be useful to enhance view
                    // when far away from the center or close to it.
                    // keep it in world space or also use factor?
                    " float camZoomDist = length(cameraPosition);",
                    // get distance between camera and star
                    // we probably want to calculate distance from stars to
                    // camera in model space, even if the final results are
                    // in scaled world coordinates. Otherwise the distance
                    // will be in world coordinates and the falloff could
                    // be way to fast. Using an uniform is the fastest way!
                    // Otherwise we would need a full inverseModelMatrix.
                    " camStarDist = distance(cameraPosition / falloff, pos.xyz);",
                    // Get magnitude from attribute
                    " float mag = position.a;",
                    // calculate apparent magnitude (physically accurate)
                    " float vmag = mag - 5.0 + 5.0 * log10(camStarDist);",
                    // calculate point size from visual magnitude
                    " gl_PointSize = magFact * exp(- magScale * vmag);",
                    // apply global point size scale
                    " gl_PointSize *= sizeScale;",
                    // make sure the point does not get too big
                    " gl_PointSize = clamp(gl_PointSize, 0.0, 75.0);",
                    // zoom field of view
                    " gl_PointSize *= fov;",
                    // attenuate sizes once we are far away
                    " gl_PointSize += clamp(camZoomDist / 50000000.0, 0.2, 3.5);",
                    // dim out stars that are very close to the camera
                    // mostly needed for our sun to outshine the screen
                    " fragColor.a *= clamp(camStarDist * 1.0e5, 0.0, 1.0);",
                    // apply min/max magnitude filtering
                    " fragColor.a -= smoothstep(minMag, maxMag, vmag);",
                    // reduce flickering of very small and faint stars
                    " fragColor.a *= smoothstep(0.0, 3.0, pow(gl_PointSize, 0.5));",
                    // apply global opacity
                    " fragColor.a *= opacity;",
                    // calculate screen position (the regular way)
                    " gl_Position = projectionMatrix * modelViewMatrix * pos;",
                    // THREE.ShaderChunk[ 'logdepthbuf_vertex'
                    " #include <logdepthbuf_vertex>",
                ].join("\n"),
                "}",
            ].join("\n");

            this.fragmentShader = [
                // Required since we are GLSL3?
                // Could just use pc_fragColor
                "out highp vec4 pc_fragColor;",
                "#define gl_FragColor pc_fragColor",
                // Add include for depth buffer (z-write)
                "#include <logdepthbuf_pars_fragment>",
                // Local uniforms
                "uniform float fillFactor;",
                "uniform float fillPower;",
                "uniform float dimming;",
                // Variables passed from vertex shader
                "varying float camStarDist;",
                "varying vec4 fragColor;",
                // Main vertex shader
                "void main() {",
                [
                    // get uv coordinates (from -0.5 to +0.5)
                    " vec2 uv = gl_PointCoord - vec2(0.5, 0.5);",
                    // calculate distance to center
                    " float dist = 1.0 - length(uv) * 2.0;",
                    " dist = smoothstep(0.0, 1.0, pow(dist, 1.25));",
                    // Fill the start billboard according to options
                    " dist = fillFactor * pow(dist, fillPower);",
                    // Optional star spikes
                    " #ifdef HAS_SPIKES",
                    " dist = max(dist, 1.0 - max(abs(uv.x), abs(uv.y)) * 2.75);", // diagonal
                    " dist = max(dist, (1.0 - abs(uv.x * 2.0)) * (1.0 - abs(uv.y * 2.0)));",
                    " #endif",
                    // Set the final color
                    " gl_FragColor = fragColor * dist;",
                    // THREE.ShaderChunk[ 'logdepthbuf_fragment' ]
                    " #include <logdepthbuf_fragment>",
                ].join("\n"),
                "}",
            ].join("\n");
            // Fixup shaders to use vec4
            this.vertexFilter = this.fragmentFilter =
                function (webglsl) {
                    return webglsl.replace(
                        /attribute vec3 position;/g,
                        'attribute vec4 position;'
                    ).replace(
                        /attribute vec[23] (?:normal|uv);/g,
                        '' // Simply remove these fully
                    );
                }
            // Hookup optional dat.gui
            if (!parameters.datgui) return;
            var gui = parameters.datgui;
            var uniforms = this.uniforms;
            if (parameters.name) gui = gui.addFolder(parameters.name)
            gui.add(uniforms.scale, 'value', -24, 64).step(0.001).name('scale');
            gui.add(uniforms.minMag, 'value', -24, 64).step(0.001).name('minMag');
            gui.add(uniforms.maxMag, 'value', -24, 64).step(0.001).name('maxMag');
            gui.add(uniforms.opacity, 'value', 0, 1).step(0.001).name('opacity');
            gui.add(uniforms.magFact, 'value', 0, 80).step(0.001).name('magFact');
            gui.add(uniforms.magScale, 'value', 0, 5).step(0.001).name('magScale');
            gui.add(uniforms.sizeScale, 'value', 0, 40).step(0.001).name('sizeScale');

            gui.add(uniforms.fillFactor, 'value', 0.5, 2).step(0.001).name('fillFactor');
            gui.add(uniforms.fillPower, 'value', 0.25, 4).step(0.001).name('fillPower');
            gui.add(uniforms.falloff, 'value', 0, 5e5).step(0.001).name('falloff');
            gui.add(uniforms.dimming, 'value', 0, 4).step(0.001).name('dimming');
        }
        // EO constructor

        // Add uniforms to material (called during ctor)
        // Do not call, this is for internal use only!
        addUniforms(uniforms) {
            super.addUniforms(uniforms);
        }
        // EO addUniforms

        updateUniforms() {
            super.updateUniforms();
        }
        // EO updateUniforms

    }

    // ######################################################################
    // ######################################################################

    FirmamentShader.prototype.time = null;
    FirmamentShader.prototype.fov = null;
    FirmamentShader.prototype.scale = null;
    FirmamentShader.prototype.minMag = null;
    FirmamentShader.prototype.maxMag = null;
    FirmamentShader.prototype.opacity = null;
    FirmamentShader.prototype.magFact = null;
    FirmamentShader.prototype.magScale = null;
    FirmamentShader.prototype.sizeScale = null;

    // assign class to global namespace
    THRAPP.FirmamentShader = FirmamentShader;

    // ######################################################################
    // ######################################################################
})(THREE, THRAPP);
  // EO private scope
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

// https://meetingorganizer.copernicus.org/EPSC-DPS2011/EPSC-DPS2011-996.pdf
// https://github.com/astroswarm/skychart/blob/409feca34e5eecb539933eb935fb9a490a71bbf9/skychart/cu_smallsat.pas
// https://www.cloudynights.com/topic/699134-incorrect-positions-of-planetary-satellites-in-cartes-du-ciel-and-stellarium/


if (!window.THRAPP) {
  window.THRAPP = {};
}

// private scope
(function (THREE, THRAPP) {
  "use strict";

  class OrbitalsShader extends THRAPP.CustomRawShader {

    constructor(parameters) {
      super(parameters);
      //this.parameters.asd = 123;
      // this.defines['ELEMENTS_VSOP'] = 1;
      this.defines['USE_LOGDEPTHBUF'] = 1;
      this.defines['USE_LOGDEPTHBUF_EXT'] = 1;
      this.isRawShaderMaterial = true;

      this.uniforms.time = { type: 'f', value: parameters.scale || 0.0 };
      this.uniforms.scale = { type: 'f', value: parameters.scale || 1.0 };
      this.uniforms.lucency = { type: 'f', value: parameters.lucency || 0.75 };
      this.uniforms.attenuate = { type: 'f', value: parameters.attenuate || 0.0 };
      this.uniforms.trailStart = { type: 'f', value: parameters.trailStart || 0.0 };
      this.uniforms.trailLength = { type: 'f', value: parameters.trailLength || 1.0 };

      if (this.defines['LAPLACE_PLANE'] != null) {
        this.uniforms.laplaceEpoch = { type: 'f', value: parameters.laplaceEpoch || 0.0 };

      }

      this.vertexShader = `

        #define varying out
        #define attribute in
        out highp vec4 pc_fragColor;
        #define gl_FragColor pc_fragColor
        #define gl_FragDepthEXT gl_FragDepth

        precision highp float;
        precision highp int;
        #define HIGH_PRECISION
        #define SHADER_NAME CustomLineMaterial
        #define GAMMA_FACTOR 2
        uniform mat4 viewMatrix;
        uniform vec3 cameraPosition;
        uniform bool isOrthographic;
        uniform mat4 modelMatrix;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        uniform mat3 normalMatrix;

        // ***************************************************************
        // orbit.vert
        // ***************************************************************
        #include <common>
        #include <logdepthbuf_pars_vertex>

        // Gravitational Constant
        #ifdef USE_GLOBAL_GM
        uniform float GM;
        #else
        attribute float GM;
        #endif
        
        // Gravitational Constant
        #ifdef USE_GLOBAL_EPOCH
        uniform float epoch;
        #else
        attribute float epoch;
        #endif

        // time in julian days
        // uniform float time;
        uniform float time;
        
        //uniform float itime;
        //uniform float ftime;
        
        // global lucency value
        uniform float lucency;
        uniform float attenuate;
        
        // scale the positions
        uniform float scale;
        uniform float trailLength;
        uniform float trailStart;
        
        // from interleaved buffer
        //attribute vec2 epoch;
        attribute vec3 color;
        attribute vec3 l_orbitals;
        attribute vec3 h_orbitals;
        attribute float rotate;

        // dynamic laplace plane
        #ifdef LAPLACE_PLANE
        attribute vec4 laplace;
        uniform float laplaceEpoch;
        #endif

        attribute vec2 precession;
        
        // position around ellipse
        attribute float position;
        attribute float position3;

        // pass to fragment shader
        varying vec4 fragColor;

// ***************************************************************
// calculate position from VSOP elements (alkhqp)
// this function is adapted from VSOP2013.f
// ***************************************************************
#ifdef ELEMENTS_VSOP

	vec3 orb2cart(float arc, float a, float l, float k, float h, float q, float p)
	{

		float fi = sqrt(1.0 - k*k - h*h);
		float ki = sqrt(1.0 - q*q - p*p);
		float u = 1.0 / (1.0 + fi);
		vec2 z = vec2(k, h);

		float ex = length(z);
		float ex2 = ex * ex;
		float ex3 = ex2 * ex;

    float n = sqrt(GM / a / a / a);
    // orbit._n = sqrt(orbit._G / pow(orbit._a, 3.0));
		float gl = mod(l + (time - epoch) * n + arc, PI2);
		float gm = gl - atan(h, k);
		float e = gl + (ex - 0.125 * ex3) * sin(gm)
				+ 0.5 * ex2 * sin(2.0 * gm)
				+ 0.375 * ex3 * sin(3.0 * gm);

		vec2 z3;
		vec2 zteta;
		float rsa = 0.0;

		for (int count = 0; count < 10; count ++) {
			zteta.x = cos(e);
			zteta.y = sin(e);
			z3.x = k*zteta.x+h*zteta.y;
			z3.y = k*zteta.y-h*zteta.x;
			float dl = gl - e + z3.y;
			rsa = 1.0 - z3.x;
			// not sure if the branching is more expensive
			// what we gain from not running the whole loop
			if (abs(dl) < 1e-15) break;
			e += dl / rsa;
		}

		// optimized for performance
		float ztox = (zteta.x - z.x + z.y * u * z3.y) / rsa;
		float ztoy = (zteta.y - z.y - z.x * u * z3.y) / rsa;

		float r = a * rsa;
		float m = p * ztox - q * ztoy;

		return vec3(
			r * (ztox - 2.0 * p * m),
			r * (ztoy + 2.0 * q * m),
			-2.0 * r * ki * m
		);

	}

// ***************************************************************
// calculate position from orbital elements
// ***************************************************************
#else

	vec3 orb2cart(float arc, float e, float a, float i, float O, float w, float M0)
	{

		// ToDo: time should be in double precision
		// needs two uniforms: 32ipart and 32fpart

		// Calculate mean anomaly M(t)
		// with u for sun as central body
		float dt = time - epoch; // + 0.5 / 365.25;

    // dynamic laplace plane
		#ifdef LAPLACE_PLANE
			// adjust for laplace precession
			//float rot_O = (time - laplaceEpoch) * laplace.z;
			// rot_O -= (laplaceEpoch * laplace.z);
			//float rot_W = (time - laplaceEpoch) * laplace.w;
			// rot_W -= (laplaceEpoch * laplace.w);
			// rotate into laplace plane
			//O -= laplace.x;
      //w -= laplace.y;
      //i -= laplace.z;

			//w += rot_W;
		#endif

    O += dt * precession.x;
    w += dt * precession.y;

		// calculate orbital period factor
		float n = sqrt(pow(a, 3.0) / GM);

		// M = CYCLE(orbit._n * (dt - orbit._T - epoch))
		float M = M0 + dt / n;
    // M += 0.1758;


		// solve the kepler equation
		// M(t) = E(t) - s * sin(E)
		// for the eccentric anomaly E(t)
		// this must be done iteratively
		float E = mod(M, PI2);

		// M = orbit._n * (dt - orbit._T - epoch);

		// we can either add arc first, to adjust
		// the offset with the actual speed the
		// object would travel. But this gives
		// a bad distribution of points on the
		// ellipsis. Comet icarus would have a
		// very rough bump on the periapsis.

		// Newton-Raphson method to solve
		// f(E) = M - E + e * sin(E) = 0
		for (int it = 0; it < 20; ++it) {
			float f = M - E + e * sin(E);
			float dfdE = e * cos(E) - 1.0;
			float dE = f / dfdE;
			E -= dE; // next iteration
		}

		// add offset now to distribute
		// the vertices accordingly
		E = mod(E, PI2) + arc;
		// E = 4.769749851054432 + arc;

		// Obtain the true anomaly vector(t)
		float v1 = sqrt(1.0 + e) * sin(E/2.0);
		float v2 = sqrt(1.0 - e) * cos(E/2.0);
		float m = 2.0 * atan( v1, v2 );

		// Distance to true anomaly position
		float r = a * (1.0 - e * cos(E));

		// Factors for projection
		float px = r * cos(m);
		float py = r * sin(m);

		// Precalculations
		float cosW = cos(w);
		float cosO = cos(O);
		float cosI = cos(i);
		float sinW = sin(w);
		float sinO = sin(O);
		float sinI = sin(i);

		float sinWcosO = sinW*cosO;
		float sinWsinO = sinW*sinO;
		float cosWcosO = cosW*cosO;
		float cosWsinO = cosW*sinO;

		float FxX = (cosW*cosO - sinW*sinO*cosI);
		float FyX = (cosW*sinO + sinW*cosO*cosI);
		float FxY = (cosW*sinO*cosI + sinW*cosO);
		float FyY = (cosW*cosO*cosI - sinW*sinO);
		float FzX = (sinW*sinI);
		float FzY = (cosW*sinI);

		// calculate cartesian coordinates
		float x = + px * FxX - py * FxY;
		float y = + px * FyX + py * FyY;
		float z = + px * FzX + py * FzY;

		vec3 coord = vec3(x, y, z);

		// dynamic laplace plane
		#ifdef LAPLACE_PLANE

			// laplace precession
			float node = (laplace.x + PI * 0.5);
			float incl = (PI * 0.5 - laplace.y);

			mat3 rotX = mat3(
				1.0, 0.0, 0.0,
				0.0, cos(incl), sin(incl),
				0.0, - sin(incl), cos(incl)
			);
//
//			mat3 rotY = mat3(
//				cos(ay), 0.0, sin(ay),
//				0.0, 1.0, 0.0,
//				- sin(ay), 0.0, cos(ay)
//			);
//
      mat3 rotZ = mat3(
				cos(node), sin(node), 0.0,
				- sin(node), cos(node), 0.0,
				0.0, 0.0, 1.0
			);
//return coord;
			return rotZ * rotX * coord;
			// return coord * rotX * rotZ;

		#else

			return vec3(
				x, y, z
			);

		#endif


		// Get derivates for velocity
		// float vf = sqrt(GM * a) / r;
		// float vx = vf * - sin(E);
		// float vy = vf * sqrt(1.0 - e*e) * cos(E);
		// Calculate velocity
		// return vec3(
		// 	+ vx * FxX - vy * FxY,
		// 	+ vx * FyX + vy * FyY,
		// 	+ vx * FzX + vy * FzY,
		// );

	}

#endif

// ***************************************************************
// ***************************************************************

void main()
{

	// attenuate the more away from current position
	// fragColor = vec4(color, 0.35 - 0.275 * pow(abs(position), .1));

    fragColor = vec4(color, 1.0); // vec4(color, (1.0 - position) * 0.75 + 0.25);

	// attenuate the orbit to create a trail (position is linear from 0 to 1)
	fragColor.a *= (pow(exp(-position * attenuate), 2.0)) * lucency;

    float foo = 1.0 + smoothstep(0.9, 1.0, position) * (step(attenuate, 0.0) - 1.0);

    fragColor.a *= foo;

    //fragColor.a *= (1.0 - position);

	// calculate the actual position
	vec3 pos = orb2cart((position * - trailLength) * PI2 + (trailStart) * PI2,
		l_orbitals[0], l_orbitals[1], l_orbitals[2],
		h_orbitals[0], h_orbitals[1], h_orbitals[2]
	);

	// calculate the final world position to be drawn
	gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );

	// THREE.ShaderChunk[ 'logdepthbuf_vertex'
	#include <logdepthbuf_vertex>

}

// ***************************************************************
// ***************************************************************


        `;

      this.fragmentShader = `
        #define varying in
        out highp vec4 pc_fragColor;
        #define gl_FragColor pc_fragColor
        #define gl_FragDepthEXT gl_FragDepth

        // ***************************************************************
        // orbit.frag
        // ***************************************************************
        precision highp float;
        precision highp int;
        #include <common>
        #include <logdepthbuf_pars_fragment>
        
        uniform float lucency;
        varying vec4 fragColor;
        
        // ***************************************************************
        // ***************************************************************

        void main()
        {

            // passed from vertex shader
            gl_FragColor = fragColor;
        
            // we use translucency, since this is less error prone
            // in case you forgot to define opacity (default is 0)
            // gl_FragColor.a *= 1.0 - lucency;
        
             // gl_FragColor.a = max(gl_FragColor.a, 0.0);
            
        
            // THREE.ShaderChunk[ 'logdepthbuf_fragment' ]
            #include <logdepthbuf_fragment>

        }
        
        // ***************************************************************
        // ***************************************************************
        
        `;
      // Hookup optional dat.gui
      if (!parameters.datgui) return;
      var gui = parameters.datgui;
      var uniforms = this.uniforms;
      if (parameters.name) gui = gui.addFolder(parameters.name)
      gui.add(uniforms.lucency, 'value', 0, 1).step(0.001).name('lucency');
      gui.add(uniforms.attenuate, 'value', 0, 9).step(0.001).name('attenuate');
      gui.add(uniforms.trailStart, 'value', 0, 1).step(0.001).name('trailStart');
      gui.add(uniforms.trailLength, 'value', -1, 1).step(0.001).name('trailLength');
    }
    // EO constructor

    // Add a new light source
    addOrbital(orbital) {
      //        if (!Array.isArray(stars)) stars = [stars];
      //        for (var i = 0; i < stars.length; i++) {
      //          this.stars.push(stars[i]);
      //          this.uniforms.lightPos.value.push(new THREE.Vector3());
      //          this.uniforms.lightSize.value.push((stars[i].radius || 0) * 2);
      //        }
      //        this.defines["NUM_STARS"] += stars.length;
      //        this.needsUpdate = true;
    }
    // EO addStar

    // Add uniforms to material (called during ctor)
    // Do not call, this is for internal use only!
    addUniforms(uniforms) {
      super.addUniforms(uniforms);
      // uniforms.trail = { type: 'f', value: 0 };
      // uniforms.scale = { type: 'f', value: 0 };
      // uniforms.lucency = { type: 'f', value: 0 };


      // uniforms.eclipserSize = { type: "fv1", value: [] };
      // uniforms.eclipserPos = { type: "v3v", value: [] };
      // uniforms.lightSize = { type: "fv1", value: [] };
      // uniforms.lightPos = { type: "v3v", value: [] };
      // uniforms.laserSize = { type: "f", value: 5e-7 };
      // uniforms.bodyRadius = { type: "f", value: 5e-7 };
    }
    // EO addUniforms

    updateUniforms() {
      var self = this,
        uniforms = self.uniforms,
        eclipsers = self.eclipsers,
        stars = self.stars;
      super.updateUniforms();
      // if (self.pbody) {
      //   self.pbody.updateMatrix();
      //   mat4.copy(self.pbody.matrixWorld).invert();
      // }
      // // Update eclipser positions
      // for (var i = 0; i < eclipsers.length; i += 1) {
      //   uniforms.eclipserPos.value[i].setFromMatrixPosition(eclipsers[i].matrixWorld)
      //   uniforms.eclipserPos.value[i].applyMatrix4(mat4);
      // }
      // // Update star positions
      // for (var i = 0; i < stars.length; i += 1) {
      //   uniforms.lightPos.value[i].setFromMatrixPosition(stars[i].matrixWorld)
      //   uniforms.lightPos.value[i].applyMatrix4(mat4);
      // }
    }
    // EO updateUniforms

    getVertexChunks() {
      var chunks = super.getVertexChunks();
      //***********************************************
      //***********************************************
      chunks.push({
        after: /<common>/,
        shader: [
        ],
      });

      chunks.push({
        before: /<begin_vertex>/,
        shader: [
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }

    getFragmentChunks() {
      var chunks = super.getFragmentChunks();
      //***********************************************
      //***********************************************
      chunks.push({
        after: /<common>/,
        shader: [
        ],
      });
      //***********************************************
      //***********************************************
      chunks.push({
        before: /<aomap_fragment>/,
        shader: [],
      });
      chunks.push({
        after: /<aomap_fragment>/,
        shader: [
        ],
      });
      //***********************************************
      //***********************************************
      chunks.push({
        after: /vec3 outgoingLight/,
        shader: [
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }
    // EO getFragmentChunks
  }

  // ######################################################################
  // ######################################################################

  OrbitalsShader.prototype.lucency = null;
  OrbitalsShader.prototype.attenuate = null;
  OrbitalsShader.prototype.trailLength = null;
  OrbitalsShader.prototype.trailStart = null;
  OrbitalsShader.prototype.trailEnd = null;

  // assign class to global namespace
  THRAPP.OrbitalsShader = OrbitalsShader;

  // ######################################################################
  // ######################################################################
})(THREE, THRAPP);
  // EO private scope
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

if (!window.THRAPP) {
  window.THRAPP = {};
}

// Allow to overwrite base material
THRAPP.BaseMaterial = THRAPP.BaseMaterial || 
    THRAPP.CustomMeshPhysicalMaterial;

// private scope
(function (THREE, THRAPP) {
  "use strict";

  var mat4 = new THREE.Matrix4();

  class EclipseShader extends THRAPP.BaseMaterial {
    constructor(parameters) {
      super(parameters);
      this.setDefines({
        NUM_STARS: 0,
        NUM_ECLIPSERS: 0,
      });
      this.stars = [];
      this.eclipsers = [];
      this.addStar(parameters.stars || []);
      this.addEclipser(parameters.eclipsers || []);
      this.uniforms.bodyRadius.value = parameters.radius || 0.0;
      if (parameters.laserSize != null) {
        this.defines["USE_ECLIPSE_LASER"] = "";
        this.uniforms.laserSize.value = parameters.laserSize;
      }
      this.pbody = parameters.pbody || null;
    }
    // EO constructor

    // Add a new light source
    addStar(stars) {
      if (!Array.isArray(stars)) stars = [stars];
      for (var i = 0; i < stars.length; i++) {
        this.stars.push(stars[i]);
        this.uniforms.lightPos.value.push(new THREE.Vector3());
        this.uniforms.lightSize.value.push((stars[i].radius || 0) * 2);
      }
      if (this.defines["NUM_STARS"] != this.stars.length) {
        this.defines["NUM_STARS"] = this.stars.length;
        this.needsUpdate = true;
      }
    }
    // EO addStar

    // Add a new eclipser body
    addEclipser(eclipsers) {
      if (!Array.isArray(eclipsers)) eclipsers = [eclipsers];
      for (let i = 0; i < eclipsers.length; i++) {
        this.eclipsers.push(eclipsers[i]);
        this.uniforms.eclipserPos.value.push(new THREE.Vector3());
        this.uniforms.eclipserSize.value.push((eclipsers[i].radius || 0) * 2);
      }
      if (this.defines["NUM_ECLIPSERS"] != this.eclipsers.length) {
        this.defines["NUM_ECLIPSERS"] = this.eclipsers.length;
        this.needsUpdate = true;
      }
    }
    // EO addEclipser

    // Add uniforms to material (called during ctor)
    // Do not call, this is for internal use only!
    addUniforms(uniforms) {
      super.addUniforms(uniforms);
      uniforms.eclipserSize = { type: "fv1", value: [] };
      uniforms.eclipserPos = { type: "v3v", value: [] };
      uniforms.lightSize = { type: "fv1", value: [] };
      uniforms.lightPos = { type: "v3v", value: [] };
      uniforms.laserSize = { type: "f", value: 5e-7 };
      uniforms.bodyRadius = { type: "f", value: 5e-7 };
    }
    // EO addUniforms

    updateUniforms() {
      var self = this,
        uniforms = self.uniforms,
        eclipsers = self.eclipsers,
        stars = self.stars;
      super.updateUniforms();
      if (self.pbody) {
        self.pbody.updateMatrix();
        mat4.copy(self.pbody.matrixWorld).invert();
      }
      // Update eclipser positions
      for (var i = 0; i < eclipsers.length; i += 1) {
        uniforms.eclipserPos.value[i].setFromMatrixPosition(
          eclipsers[i].matrixWorld
        );
        uniforms.eclipserPos.value[i].applyMatrix4(mat4);
      }
      // Update star positions
      for (var i = 0; i < stars.length; i += 1) {
        uniforms.lightPos.value[i].setFromMatrixPosition(stars[i].matrixWorld);
        uniforms.lightPos.value[i].applyMatrix4(mat4);
      }
    }
    // EO updateUniforms

    debug(i, n) {
      var vector = new THREE.Vector3();
      var lightPos = this.uniforms.lightPos.value;
      var lightSize = this.uniforms.lightSize.value;
      var eclipserPos = this.uniforms.eclipserPos.value;
      var eclipserSize = this.uniforms.eclipserSize.value;
      var bodyRadius = this.uniforms.bodyRadius.value;
      console.log("Body Radius: ", bodyRadius);
      console.log(
        "Light[",
        i,
        "] - size: ",
        lightSize[i],
        ", pos: ",
        lightPos[i]
      );
      console.log(
        "Eclipser[",
        n,
        "] - size: ",
        eclipserSize[n],
        ", pos: ",
        eclipserPos[n]
      );
      var L1 = vector.copy(lightPos[i]).sub(eclipserPos[n]).length();
      var L2 = eclipserPos[n].length() - bodyRadius;
      var D1 = lightSize[i];
      var D2 = eclipserSize[n];
      var P = (D1 / L1) * L2;
      var U = (D2 / L1) * (L1 + L2) - P;
      console.log("Umbra(outer): ", U, ", Penumbra(core): ", P);
    }

    getVertexChunks() {
      var chunks = super.getVertexChunks();
      //***********************************************
      //***********************************************
      chunks.push({
        after: /<common>/,
        shader: ["  // Local vertex position", "  varying vec3 vertexPos;"],
      });

      chunks.push({
        before: /<begin_vertex>/,
        shader: [
          " // Pass vertex position to fragments",
          "  vertexPos = position;",
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }

    getFragmentChunks() {
      var chunks = super.getFragmentChunks();
      //***********************************************
      //***********************************************
      chunks.push({
        after: /<common>/,
        shader: [
          "  uniform float bodyRadius;",
          "#ifdef USE_ECLIPSE_LASER",
          "  uniform float laserSize;",
          "#endif",
          "#if NUM_STARS > 0",
          "  uniform vec3 lightPos[NUM_STARS];",
          "  uniform float lightSize[NUM_STARS];",
          "#endif",
          "#if NUM_ECLIPSERS > 0",
          "  uniform vec3 eclipserPos[NUM_ECLIPSERS];",
          "  uniform float eclipserSize[NUM_ECLIPSERS];",
          "#endif",
          "  // Local vertex position",
          "  varying vec3 vertexPos;",
          "  // Scale from local to world",
          "  varying vec3 localScale;",
          "  // Rotate from local to world",
          // "  varying mat4 localRotation;",
          "  // Rotate and scale to world",
          "  varying mat4 localRotScale;",
          "  // Translate back to local space",
          "  varying mat4 modelMatrixInverse;",
        ],
      });
      // extend fragment shaders
      chunks.push({
        after: /<common>/,
        shader: [
          "  float lineDistToPoint(vec3 A, vec3 B, vec3 P) {",
          "    // represent the line segment AB as a vector.",
          "    vec3 AB = B - A;",
          "    // determine the direction of B relative to A.",
          "    vec3 AB_dir = normalize( AB );",
          "    // compute the distance between A and Q using the dot",
          "    // product trick.  The first argument is a unit length",
          "    // vector.  The second argument is a point *relative to",
          "    // that vector*.",
          "    float AQ_len = dot( AB_dir, P - A );",
          "    // Now that we know the length of AQ, we can compute Q.",
          "    // To do this, think of the following equation as start",
          "    // at A; move along the direction AB_dir by AQ_len units;",
          "    // that position is Q.",
          "    vec3 Q = A + AQ_len * AB_dir;",
          "    // return the length of PQ.",
          "    return length( Q - P );",
          "  }",
        ],
      });
      //***********************************************
      //***********************************************
      chunks.push({
        before: /<aomap_fragment>/,
        shader: ["float shadows = 1.0;"],
      });
      chunks.push({
        after: /<aomap_fragment>/,
        shader: [
          "#if NUM_STARS > 0 && NUM_ECLIPSERS > 0",
          "  float starIntensity[NUM_STARS];",
          "  #ifdef USE_ECLIPSE_LASER",
          "    vec3 laserDot = vec3(0.0, 0.0, 0.0);",
          "    vec3 laserCol = vec3(1.0, 0.0, 0.0);",
          "  #endif",
          THRAPP.StartStaticForLoop("n", "NUM_ECLIPSERS"),
          THRAPP.StartStaticForLoop("i", "NUM_STARS"),
          "      // Get light position from passed uniform. There seems to be other way",
          "      // to get these via `pointLings[n].position`, but unsure how exactly.",
          "      // Get closest distance from the vertex point to the light ray.",
          "      // We want to do this calculation in world space, but for best accuracy",
          "      // we need to get the vertex point into local space. We simply do that",
          "      // by translating all points into local space by subtracting the world",
          "      // position of the parent system (moving zero coordinate). Which would be:",
          "      // float dist = lineDistToPoint(eclipserPos[n], lightPos[i], vertexWorldPos - off);",
          "      // The last subtraction is problematic, as it looses a lot of precision.",
          "      // Instead we provide a uniform with world position of the parent frame.",
          "      // This probably ignores some scaling and maybe some rotations, but allows",
          "      // us to do the subtraction on values that are themselves rather big.",
          "      // vec3 light = (vec4(pointLights[ i ].position, 1.0) * viewMatrix).xyz;",
          "      float behind = step(0.0, length(vertexPos - lightPos[i]) - length(lightPos[i]));",
          "      float dist = lineDistToPoint(eclipserPos[n], lightPos[i], vertexPos) + behind * 9e32;",
          "      // inner umbra and quadratic falloff for outer penumbra",
          "      // calculate umbra and penumbra from radii and distances",
          "      // http://www.opticiansfriend.com/articles/equations.html#Shadows",
          "      // Length from light source to L1 & Length from L1 to Umbra",
          "      float L1 = length(lightPos[i] - eclipserPos[n]);",
          "      float L2 = length(eclipserPos[n]) - bodyRadius;",
          "      float D1 = lightSize[i];", // Diameter of light source
          "      float D2 = eclipserSize[n];", // Diameter of object between
          "      float P = D1 / L1 * L2;",
          "      float U = D2 / L1 * (L1 + L2) - P;",
          "      U = max(U, 0.0); P = max(P, U);", // 0 < U < P
          "      starIntensity[i] += pow(smoothstep(U*.97, P, dist), 0.5);",
          "      #ifdef USE_ECLIPSE_LASER",
          "        laserDot += smoothstep(laserSize, laserSize*.2, dist) * laserCol;",
          "      #endif",
          THRAPP.EndStaticForLoop("i", "NUM_STARS"),
          THRAPP.EndStaticForLoop("n", "NUM_ECLIPSERS"),
          "  float globalIntensity = 0.0;",
          THRAPP.StartStaticForLoop("m", "NUM_STARS"),
          "    starIntensity[m] /= float(NUM_ECLIPSERS);",
          "    globalIntensity += starIntensity[m] / float(NUM_STARS);",
          THRAPP.EndStaticForLoop("m", "NUM_STARS"),
          "  shadows *= pow(clamp(globalIntensity, 0.0, 1.0), 2.0);",
          "#endif",
        ],
      });
      //***********************************************
      //***********************************************
      chunks.push({
        after: /vec3 outgoingLight/,
        shader: [
          "outgoingLight *= clamp(0.0, 1.0, shadows);",
          "#if NUM_STARS > 0 && NUM_ECLIPSERS > 0",
          "  #ifdef USE_ECLIPSE_LASER",
          "    outgoingLight = clamp(outgoingLight + laserDot, 0.0, 1.0);",
          "  #endif",
          "#endif",
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }
    // EO getFragmentChunks
  }

  // ######################################################################
  // ######################################################################

  EclipseShader.prototype.pbody = null;
  EclipseShader.prototype.radius = null;
  EclipseShader.prototype.stars = null;
  EclipseShader.prototype.eclipsers = null;
  EclipseShader.prototype.laserSize = null;

  // assign class to global namespace
  THRAPP.EclipseShader = EclipseShader;

  // ######################################################################
  // ######################################################################
})(THREE, THRAPP);
// EO private scope
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

if (!window.THRAPP) {
  window.THRAPP = {};
}

// private scope
(function (THREE, THRAPP) {
  "use strict";

  var mat4 = new THREE.Matrix4();

  class PlanetShader extends THRAPP.EclipseShader {
    constructor(parameters) {
      super(parameters);
      this.setDefines({
        NUM_RINGS: 0,
      });
      this.rings = [];
      this.addRing(parameters.rings || []);
      if (parameters.nightMap) {
        this.defines["USE_UV"] = "";
        this.defines["USE_NIGHT_MAP"] = "";
        this.uniforms.nightMap.value = parameters.nightMap;
      }
      if (parameters.ringMap) {
        this.defines["USE_RING_MAP"] = "";
        this.uniforms.ringMap.value = parameters.ringMap;
      }
    }
    // EO constructor

    // Put a new ring around
    addRing(rings) {
      if (!Array.isArray(rings)) rings = [rings];
      for (var i = 0; i < rings.length; i++) {
        this.rings.push(rings[i]);
        var radii = new THREE.Vector2(
          rings[i].innerRadius || 0,
          rings[i].outerRadius || 0
        );
        this.uniforms.ringRadii.value.push(radii);
        this.uniforms.ringNorm.value.push(new THREE.Vector3());
        this.uniforms.ringWMat4.value.push(rings[i].matrixWorld || new THREE.Matrix4());
      }
      this.defines["NUM_RINGS"] += rings.length;
      this.needsUpdate = true;
    }
    // EO addRing

    updateUniforms() {
      var self = this,
        rings = self.rings,
        uniforms = self.uniforms;
      super.updateUniforms();
      if (self.pbody) mat4.copy(self.pbody.matrixWorld).invert();
      for (var i = 0; i < rings.length; i += 1) {
        uniforms.ringNorm.value[i].set(0, 0, 1)
          .applyMatrix4(rings[i].matrixWorld)
          .applyMatrix4(mat4);
      }
    }

    addUniforms(uniforms) {
      super.addUniforms(uniforms);
      uniforms.nightMap = { type: "t", value: null };
      uniforms.ringMap = { type: "t", value: null };
      uniforms.ringWMat4 = { type: "vm4", value: [] };
      uniforms.ringNorm = { type: "v3v", value: [] };
      uniforms.ringRadii = { type: "v2v", value: [] };
    }

    getVertexChunks() {
      var chunks = super.getVertexChunks();
      //***********************************************
      //***********************************************
      return chunks;
    }

    getFragmentChunks() {
      var chunks = super.getFragmentChunks();
      //***********************************************
      //***********************************************
      chunks.push({
        after: /<common>/,
        shader: [
          "#ifdef USE_NIGHT_MAP",
          "  uniform sampler2D nightMap;",
          "#endif",
        ],
      });
      chunks.push({
        after: /vec3 outgoingLight/,
        shader: [
          "#ifdef USE_NIGHT_MAP",
          "  float hasLight = 0.0;",
          THRAPP.StartStaticForLoop("i", "NUM_STARS"), 
          "    float girrad = dot(-normalize(vertexPos), normalize(lightPos[i]));",
          "    hasLight += pow(1.0 - clamp(girrad, 0.0, 1.0), 4.0);",
          "#ifdef DEBUG_DAYLIGHT_TERMINATOR",
          "    if (girrad < 0.01 && girrad > 0.0) outgoingLight.r = 1.0; ",
          "#endif",
          THRAPP.EndStaticForLoop("i", "NUM_STARS"), 
          "  outgoingLight += texture2D(nightMap, vUv).xyz * clamp(1.0 - hasLight, 0.0, 1.0);",
          "#else",
          "#endif",
        ],
      });
      //***********************************************
      //***********************************************
      chunks.push({
        after: /<common>/,
        shader: [
          "#ifdef USE_RING_MAP",
          "  uniform sampler2D ringMap;",
          "#endif",
          "#if NUM_RINGS > 0",
          "  uniform vec2 ringRadii[NUM_RINGS];",
          "  uniform mat4 ringWMat4[NUM_RINGS];",
          "  uniform vec3 ringNorm[NUM_RINGS];",
          "#endif",
        ],
      });
      chunks.push({
        after: /<aomap_fragment>/,
        shader: [
          "float ringShadows = 1.0;",
          "#if NUM_RINGS > 0 && NUM_STARS > 0",
          "  float ringShadow[NUM_STARS];",
          THRAPP.StartStaticForLoop("n", "NUM_RINGS"), 
          "    vec3 axisWorldDir = normalize(ringNorm[n]);",
          "    ringShadow[n] = 0.0;", // init value first
          THRAPP.StartStaticForLoop("i", "NUM_STARS"), 
          "      // Intersect the vertex point with the ring plane and return distance to center.",
          "      // From there we can calculate if it lies between inner and outer radius.",
          "      float d = dot(-vertexPos, axisWorldDir) / dot(lightPos[i], axisWorldDir);", // dot magic
          "      vec3 p = vertexPos + lightPos[i] * d;", // intersection point on plane
          "      // Check if distance is between inner and outer radius",
          "      float range = (ringRadii[n].y - ringRadii[n].x) / 2.0;",
          "      float dist = abs(length(p) - ringRadii[n].x - range);",
          "      float fact = 1.0 - clamp(pow(dist / range, 8.0), 0.0, 1.0);",
          "      fact *= step(0.0, d);", // Only shade behind ring is visible
          "#ifdef USE_RING_MAP",
          "        vec2 rUv = vec2(0.5, 1.0 - (length(p) - ringRadii[n].x) / range / 2.0);",
          "        vec4 tex = texture2D(ringMap, rUv);",
          "        // Calculate luminance at the texture position",
          "        float lum = 0.2126*tex.r + 0.7152*tex.g + 0.0722*tex.b;",
          "        ringShadow[n] += fact * pow(lum, 0.5) * pow(tex.a, 0.5);",
          "#else",
          "        ringShadow[n] += fact;",
          "#endif",
          THRAPP.EndStaticForLoop("i", "NUM_STARS"), 
          THRAPP.EndStaticForLoop("n", "NUM_RINGS"), 
          THRAPP.StartStaticForLoop("i", "NUM_RINGS"), 
          "    ringShadows -= ringShadow[i] / float(NUM_STARS);",
          THRAPP.EndStaticForLoop("i", "NUM_RINGS"), 
          "  shadows *= ringShadows;",
          "#endif",
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }
    // EO getFragmentChunks
  }

  // ######################################################################
  // ######################################################################

  PlanetShader.prototype.nightMap = null;
  PlanetShader.prototype.ringMap = null;

  // assign class to global namespace
  THRAPP.PlanetShader = PlanetShader;

  // ######################################################################
  // ######################################################################
})(THREE, THRAPP);
// EO private scope
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

if (!window.THRAPP) {
  window.THRAPP = {};
}

// private scope
(function (THREE, THRAPP) {
  "use strict";

  var mat4 = new THREE.Matrix4();

  class GroundShader extends THRAPP.PlanetShader {
    constructor(parameters) {
      super(parameters);
      this.setDefines({
        USE_GROUNDSHADER: 1,
        NUM_SAMPLES: 16,
      });

      if (!parameters.camera)
        throw "Camera missing";
      this.camera = parameters.camera;

      if (parameters.atmosphere) {
        var atmosphere = parameters.atmosphere;
        var uniforms = this.uniforms;

        atmosphere.G = atmosphere.G || -0.95;
        atmosphere.Kr = atmosphere.Kr || 0.0025;
        atmosphere.Km = atmosphere.Km || 0.001;
        atmosphere.ESun = atmosphere.ESun || 20.0;
        atmosphere.bias = atmosphere.bias || 0.5;
        atmosphere.skale = atmosphere.skale || 0.5;
        atmosphere.exposure = atmosphere.exposure || 2.5;
        atmosphere.scaleDepth = atmosphere.scaleDepth || 0.25;
        atmosphere.scaleHeight = atmosphere.scaleHeight || 1.025;
        atmosphere.innerRadius = (atmosphere.innerRadius || 0);

        var wavelength = atmosphere.wavelength;
        uniforms.v3InvWavelength.value.set(
          1.0 / Math.pow(wavelength.x, 4.0),
          1.0 / Math.pow(wavelength.y, 4.0),
          1.0 / Math.pow(wavelength.z, 4.0)
        );

        var G = atmosphere.G;
        uniforms.fg.value = G;
        uniforms.fg2.value = G * G;

        var Kr = atmosphere.Kr;
        var Km = atmosphere.Km;
        var ESun = atmosphere.ESun;
        uniforms.fKrESun.value = Kr * ESun;
        uniforms.fKmESun.value = Km * ESun;
        uniforms.fKr4PI.value = Kr * 4 * Math.PI;
        uniforms.fKm4PI.value = Km * 4 * Math.PI;

        var sd = atmosphere.scaleDepth;
        var sh = atmosphere.scaleHeight;
        var innerRadius = atmosphere.innerRadius;
        var outerRadius = innerRadius + atmosphere.height;
        uniforms.fBias.value = atmosphere.bias;
        uniforms.fExposure.value = atmosphere.exposure;
        var scale = 1.0 / (outerRadius - innerRadius);
        uniforms.fScale.value = scale;
        uniforms.fScaleDepth.value = sd;

        uniforms.fOuterRadius.value = outerRadius;
        uniforms.fInnerRadius.value = innerRadius;
        uniforms.fOuterRadius2.value = outerRadius * outerRadius;
        uniforms.fInnerRadius2.value = innerRadius * innerRadius;
      }
    }

    updateUniforms() {
      var self = this,
        uniforms = self.uniforms;
      super.updateUniforms();
      // Get Vector3 objects to update
      var camPos = uniforms.fCameraPos.value;
      // Get world coordinates of objects
      camPos.setFromMatrixPosition(camera.matrixWorld)
      // Calculate the world to local matrix
      if (self.pbody && self.pbody.matrixWorld) {
        mat4.copy(self.pbody.matrixWorld).invert();
        // Transform world to local coordinates
        camPos.applyMatrix4(mat4);
      }
      // Update derived uniforms
      var h2 = camPos.lengthSq(),
        h = Math.sqrt(h2);
      uniforms.fCameraHeight.value = h;
      uniforms.fCameraHeight2.value = h2;
    }

    addUniforms(uniforms) {
      super.addUniforms(uniforms);
      uniforms.fg = { type: "f", value: 0 };
      uniforms.fg2 = { type: "f", value: 0 };
      uniforms.fKrESun = { type: "f", value: 0 };
      uniforms.fKmESun = { type: "f", value: 0 };
      uniforms.fKr4PI = { type: "f", value: 0 };
      uniforms.fKm4PI = { type: "f", value: 0 };
      uniforms.fScale = { type: "f", value: 0 };
      uniforms.fBias = { type: "f", value: 0 };
      uniforms.fExposure = { type: "f", value: 0 };
      uniforms.fScaleDepth = { type: "f", value: 0 };
      uniforms.fOuterRadius = { type: "f", value: 0 };
      uniforms.fInnerRadius = { type: "f", value: 0 };
      uniforms.fOuterRadius2 = { type: "f", value: 0 };
      uniforms.fInnerRadius2 = { type: "f", value: 0 };
      uniforms.fCameraHeight = { type: "f", value: 0 };
      uniforms.fCameraHeight2 = { type: "f", value: 0 };
      uniforms.v3InvWavelength = { type: "v3", value: new THREE.Vector3() };
      uniforms.fCameraPos = { type: "v3", value: new THREE.Vector3() };
    }

    getVertexChunks() {
      var chunks = super.getVertexChunks();
      //***********************************************
      //***********************************************
      chunks.push({
        after: /<common>/,
        shader: [
          "#if USE_GROUNDSHADER > 0 && NUM_STARS > 0",

          "  uniform vec3 lightPos[NUM_STARS];",
          "  uniform float lightSize[NUM_STARS];",

          "  uniform vec3 fCameraPos;       // The Camera Position",
          "  uniform vec3 v3InvWavelength;   // 1 / pow(abs(wavelength), 4) for the red, green, and blue channels",
          "  uniform float fCameraHeight;    // The cameras current height",
          "  uniform float fCameraHeight2;   // fCameraHeight^2",
          "  uniform float fOuterRadius;     // The outer (atmosphere) radius",
          "  uniform float fOuterRadius2;    // fOuterRadius^2",
          "  uniform float fInnerRadius;     // The inner (planetary) radius",
          "  uniform float fInnerRadius2;    // fInnerRadius^2",
          "  uniform float fKrESun;          // Kr * ESun",
          "  uniform float fKmESun;          // Km * ESun",
          "  uniform float fKr4PI;           // Kr * 4 * PI",
          "  uniform float fKm4PI;           // Km * 4 * PI",
          "  uniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)",
          "  uniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmospheres average density is found)",
          "  uniform float fBias;            // GroundShader Bias",

          "  varying vec3 v3RayleighColor;",
          "  varying vec3 v3MieColor;",

          "  float scale(float fCos)",
          "  {",
          "  	float x = 1.0 - fCos;",
          "  	return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));",
          "  }",

          "#endif",
        ],
      });
      chunks.push({
        after: /<begin_vertex>/,
        shader: [
          "#if USE_GROUNDSHADER > 0 && NUM_STARS > 0",
          "  v3RayleighColor *= 0.0;",
          "  v3MieColor *= 0.0;",
          "  float fInvScaleDepth = (1.0 / fScaleDepth);",
          "  float fScaleOverScaleDepth = fScale / fScaleDepth;",
          
          "  // Do all the calculation in local space, since this yields best precision",
          "  vec3 cameraLocal = fCameraPos; // vec3(modelMatrixInverse * vec4(cameraPosition, 1.0));",

          "  // Get the ray from the camera to the vertex and its length",
          "  // which is the far point of the ray passing through the atmosphere",
          "  vec3 v3Ray = position - cameraLocal;",
          "  float fFar = length(v3Ray);",
          "  v3Ray /= fFar;",

          "  // Calculate the closest intersection of the ray with the outer atmosphere",
          "  // Which is the near point of the ray passing through the atmosphere",
          "  float B = 2.0 * dot(cameraLocal, v3Ray);",
          "  float C = fCameraHeight2 - fOuterRadius2;",
          "  float fDet = max(0.0, B*B - 4.0 * C);",
          "  float fNear = 0.5 * (-B - sqrt(fDet));",

          "  float fDepth = exp((fInnerRadius - fOuterRadius) * fScaleOverScaleDepth);",
          "  float fCameraAngle = dot(-v3Ray, position) / length(position);",
          "  float fCameraScale = scale(fCameraAngle);",
          "  float fCameraOffset = fDepth*fCameraScale;",

          THRAPP.StartStaticForLoop("n", "NUM_STARS"),
          "    // Do all the calculation in local space, since this yields best precision",
          "    vec3 lightLocal = lightPos[n]; // vec3(modelMatrixInverse * vec4(starPos[n], 1.0));",
          "    // Calculate the ray's starting position, then calculate its scattering offset",
          "    vec3 v3Start = cameraLocal + v3Ray * fNear;",
          "    fFar -= fNear;",
          "    float fLightAngle = dot(lightLocal, position) / length(position);",
          "    float fLightScale = scale(fLightAngle);",
          "    float fTemp = (fLightScale + fCameraScale);",

          "    // Initialize the scattering loop variables",
          "    float fSampleLength = fFar / float(NUM_SAMPLES);",
          "    float fScaledLength = fSampleLength * fScale;",
          "    vec3 v3SampleRay = v3Ray * fSampleLength;",
          "    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;",

          "    // Now loop through the sample rays",
          "    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);",
          "    vec3 v3Attenuate;",
          "    for(int i=0; i<NUM_SAMPLES; i++)",
          "    {",
          "        float fHeight = length(v3SamplePoint);",
          "        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));",
          "        float fScatter = fDepth*fTemp - fCameraOffset;",
          "        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));",
          "        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);",
          "        v3SamplePoint += v3SampleRay;",
          "    }",

          "    v3RayleighColor += v3FrontColor * (v3InvWavelength * fKrESun + fKmESun) / float(NUM_STARS);",
          "    v3MieColor += v3Attenuate / float(NUM_STARS);",

          THRAPP.EndStaticForLoop("n", "NUM_STARS"),
          "#endif",
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }

    getFragmentChunks() {
      var chunks = super.getFragmentChunks();
      //***********************************************
      //***********************************************
      chunks.push({
        after: /<common>/,
        shader: [
          "#if USE_GROUNDSHADER > 0 && NUM_STARS > 0",
          "  varying vec3 v3RayleighColor;",
          "  varying vec3 v3MieColor;",
          "  uniform float fBias;",
          "#endif",
        ],
      });
      chunks.push({
        after: /vec3 outgoingLight/,
        shader: [
          "#if USE_GROUNDSHADER > 0 && NUM_STARS > 0",
          "  vec3 color = v3RayleighColor + 0.25 * v3MieColor;",
          "  outgoingLight = mix(outgoingLight, color, fBias);",
          "#endif",
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }
  }

  // ######################################################################
  // ######################################################################

  GroundShader.prototype.atmosphere = null;

  // assign class to global namespace
  THRAPP.GroundShader = GroundShader;

  // ######################################################################
  // ######################################################################
})(THREE, THRAPP);
// EO private scope
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

if (!window.THRAPP) {
  window.THRAPP = {};
}

// private scope
(function (THREE, THRAPP) {
  "use strict";

  var mat4 = new THREE.Matrix4();

  class SkyShader extends THRAPP.CustomMaterial(
    THREE.ShaderMaterial,
    "ShaderMaterial",
    "basic"
  ) {
    constructor(parameters) {
      super(parameters);
      this.setDefines({
        NUM_STARS: 0,
        USE_ATMOSPHERE: "",
      });
      if (parameters.atmosphere) {
        var atmosphere = parameters.atmosphere;
        var uniforms = this.uniforms;

        atmosphere.G = atmosphere.G || -0.95;
        atmosphere.Kr = atmosphere.Kr || 0.0025;
        atmosphere.Km = atmosphere.Km || 0.001;
        atmosphere.ESun = atmosphere.ESun || 20.0;
        atmosphere.bias = atmosphere.bias || 0.5;
        atmosphere.skale = atmosphere.skale || 0.5;
        atmosphere.exposure = atmosphere.exposure || 2.5;
        atmosphere.scaleDepth = atmosphere.scaleDepth || 0.25;
        atmosphere.scaleHeight = atmosphere.scaleHeight || 1.025;
        atmosphere.innerRadius = atmosphere.innerRadius || r * KM2AU;

        var wavelength = atmosphere.wavelength;
        uniforms.v3InvWavelength.value.set(
          1.0 / Math.pow(wavelength.x, 4.0),
          1.0 / Math.pow(wavelength.y, 4.0),
          1.0 / Math.pow(wavelength.z, 4.0)
        );

        var G = atmosphere.G;
        uniforms.fg.value = G;
        uniforms.fg2.value = G * G;

        var Kr = atmosphere.Kr;
        var Km = atmosphere.Km;
        var ESun = atmosphere.ESun;
        uniforms.fKrESun.value = Kr * ESun;
        uniforms.fKmESun.value = Km * ESun;
        uniforms.fKr4PI.value = Kr * 4 * Math.PI;
        uniforms.fKm4PI.value = Km * 4 * Math.PI;

        var sd = atmosphere.scaleDepth;
        var sh = atmosphere.scaleHeight;
        var innerRadius = atmosphere.innerRadius;
        var outerRadius = innerRadius + atmosphere.height;
        uniforms.fBias.value = atmosphere.bias;
        uniforms.fExposure.value = atmosphere.exposure;
        var scale = 1.0 / (outerRadius - innerRadius);
        uniforms.fScale.value = scale;
        uniforms.fScaleDepth.value = sd;

        uniforms.fOuterRadius.value = outerRadius;
        uniforms.fInnerRadius.value = innerRadius;
        uniforms.fOuterRadius2.value = outerRadius * outerRadius;
        uniforms.fInnerRadius2.value = innerRadius * innerRadius;
      }

      this.stars = [];
      this.addStar(parameters.stars || []);
    }

    // Add a new light source
    addStar(stars) {
      if (!Array.isArray(stars)) stars = [stars];
      for (var i = 0; i < stars.length; i++) {
        this.stars.push(stars[i]);
        this.uniforms.lightPos.value.push(new THREE.Vector3());
        this.uniforms.lightSize.value.push((stars[i].radius || 0) * 2);
      }
      this.defines["NUM_STARS"] += stars.length;
      this.needsUpdate = true;
    }
    // EO addStar

    updateUniforms() {
      var self = this,
        uniforms = self.uniforms,
        stars = self.stars;
      // Get Vector3 objects to update
      var sunPos = uniforms.v3LightPos.value;
      var camPos = uniforms.v3CameraPos.value;
      // Get world coordinates of objects
      camPos.setFromMatrixPosition(camera.matrixWorld)
      sunPos.setFromMatrixPosition(light.matrixWorld)
      // Calculate the world to local matrix
      if (self.pbody && self.pbody.matrixWorld) {
        mat4.copy(self.pbody.matrixWorld).invert();
        // Transform world to local coordinates
        sunPos.applyMatrix4(mat4);
        camPos.applyMatrix4(mat4);
      }
      // Update derived uniforms
      var h2 = camPos.lengthSq(),
        h = Math.sqrt(h2);
      uniforms.fCameraHeight.value = h;
      uniforms.fCameraHeight2.value = h2;
      // Update star positions
      for (var i = 0; i < stars.length; i += 1) {
        stars[i].getWorldPosition(uniforms.lightPos.value[i]);
        uniforms.lightPos.value[i].applyMatrix4(mat4);
      }
    }

    addUniforms(uniforms) {
      super.addUniforms(uniforms);
      uniforms.fg = { type: "f", value: 0 };
      uniforms.fg2 = { type: "f", value: 0 };
      uniforms.fKrESun = { type: "f", value: 0 };
      uniforms.fKmESun = { type: "f", value: 0 };
      uniforms.fKr4PI = { type: "f", value: 0 };
      uniforms.fKm4PI = { type: "f", value: 0 };
      uniforms.fScale = { type: "f", value: 0 };
      uniforms.fBias = { type: "f", value: 0 };
      uniforms.fExposure = { type: "f", value: 0 };
      uniforms.fScaleDepth = { type: "f", value: 0 };
      uniforms.fOuterRadius = { type: "f", value: 0 };
      uniforms.fInnerRadius = { type: "f", value: 0 };
      uniforms.fOuterRadius2 = { type: "f", value: 0 };
      uniforms.fInnerRadius2 = { type: "f", value: 0 };
      uniforms.fCameraHeight = { type: "f", value: 0 };
      uniforms.fCameraHeight2 = { type: "f", value: 0 };
      uniforms.v3InvWavelength = { type: "v3", value: new THREE.Vector3() };
      uniforms.v3CameraPos = { type: "v3", value: new THREE.Vector3() };
      uniforms.v3LightPos = { type: "v3", value: new THREE.Vector3() };
      uniforms.lightSize = { type: "fv1", value: [] };
      uniforms.lightPos = { type: "v3v", value: [] };
    }

    getVertexChunks() {
      var chunks = super.getVertexChunks();
      chunks.push({
        after: /<common>/,
        shader: [
          "#if NUM_STARS > 0",
          "  uniform vec3 lightPos[NUM_STARS];",
          "  uniform float lightSize[NUM_STARS];",
          "#endif",
          "// These must be passed in local object space",
          "  uniform vec3 v3LightPos;        // The Light Position",
          "  uniform vec3 v3CameraPos;       // The Camera Position",
          "  uniform vec3 v3InvWavelength;   // 1 / pow(abs(wavelength), 4) for the red, green, and blue channels",
          "  uniform float fCameraHeight;    // The cameras current height",
          "  uniform float fCameraHeight2;   // fCameraHeight^2",
          "  uniform float fOuterRadius;     // The outer (atmosphere) radius",
          "  uniform float fOuterRadius2;    // fOuterRadius^2",
          "  uniform float fInnerRadius;     // The inner (planetary) radius",
          "  uniform float fInnerRadius2;    // fInnerRadius^2",
          "  uniform float fKrESun;          // Kr * ESun",
          "  uniform float fKmESun;          // Km * ESun",
          "  uniform float fKr4PI;           // Kr * 4 * PI",
          "  uniform float fKm4PI;           // Km * 4 * PI",
          "  uniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)",
          "  uniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmospheres average density is found)",
          "  uniform float fBias;            // GroundShader Bias",
          "  varying vec3 v3Direction;",
          "  varying vec3 v3RayleighColor;",
          "  varying vec3 v3MieColor;",
          "  varying float fMiePhase;",
          "  uniform float fg;",
          "  uniform float fg2;",
          "  const int nSamples = 16;",
          "  const float fSamples = float(nSamples); // or 1.125",
          "  float scale(float fCos)",
          "  {",
          "  	float x = 1.0 - fCos;",
          "  	return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));",
          "  }",
        ],
      });
      chunks.push({
        after: /<begin_vertex>/,
        shader: [
          "  // vec3 v3CameraPos = cameraPosition; // vec3(1.5, 0.5, 10.0);",
          "  float fCameraHeight = length(v3CameraPos);",
          "  float fCameraHeight2 = fCameraHeight * fCameraHeight;",
          "  float fInvScaleDepth = (1.0 / fScaleDepth);",
          "  float fScaleOverScaleDepth = fScale / fScaleDepth;",

          "  // Do all the calculation in local space, since this yields best precision",
          "  vec3 cameraLocal = v3CameraPos; // vec3(modelMatrixInverse * vec4(cameraPosition, 1.0));",

          "  // Get the ray from the camera to the vertex and its length",
          "  // which is the far point of the ray passing through the atmosphere",

          "  vec3 v3Pos = position; //",

          "  vec3 v3Ray = position - cameraLocal;",
          "  float fFar = length(v3Ray);",
          "  v3Ray /= fFar;",
          "  // Pass direction to fragment shader",
          "  v3Direction = v3CameraPos - v3Pos;",
          "  // Calculate the closest intersection of the ray with the outer atmosphere",
          "  // Which is the near point of the ray passing through the atmosphere",
          "  float B = 2.0 * dot(v3CameraPos, v3Ray);",
          "  float C = fCameraHeight2 - fOuterRadius2;",
          "  float fDet = max(0.0, B*B - 4.0 * C);",
          "  float fNear = 0.5 * (-B - sqrt(fDet));",
          "  // Calculate the ray's starting position, then calculate its scattering offset",
          "  vec3 v3Start = v3CameraPos + v3Ray * fNear;",
          "  fFar -= fNear;",
          "  float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;",
          "  float fStartDepth = exp(-1.0 / fScaleDepth);",
          "  float fStartOffset = fStartDepth*scale(fStartAngle);",
          "  // Initialize the scattering loop variables",
          "  float fSampleLength = fFar / fSamples;",
          "  float fScaledLength = fSampleLength * fScale;",
          "  vec3 v3SampleRay = v3Ray * fSampleLength;",
          "  vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;",
          "  // Now loop through the sample rays",
          "  vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);",
          "  for(int i=0; i<nSamples; i++)",
          "  {",
          "    float fHeight = length(v3SamplePoint);",
          "    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));",
          "    float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;",
          THRAPP.StartStaticForLoop("n", "NUM_STARS"),
          "        float fLightAngle = dot(lightPos[n], v3SamplePoint) / fHeight;",
          "        float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));",
          "        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));",
          "        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);",
          "        v3SamplePoint += v3SampleRay;",
          THRAPP.EndStaticForLoop("n", "NUM_STARS"),
          "  }",
          "  v3RayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);",
          "  v3MieColor = v3FrontColor * fKmESun;;",

          "vec3 lightPos = lightPos[0];",
          "lightPos *= 0.95;",

          "float fCos = dot(lightPos, v3Direction) / length(v3Direction);",
          "fMiePhase = 1.5 * ((1.0 - fg2) / (2.0 + fg2)) * (1.0 + fCos*fCos) / pow(1.0 + fg2 - 2.0*fg*fCos, 1.5);",
        ],
      });
      return chunks;
    }

    getFragmentChunks() {
      var chunks = super.getFragmentChunks();
      chunks.unshift({
        after: /<common>/,
        shader: [
          "#if NUM_STARS > 0",
          "  uniform vec3 lightPos[NUM_STARS];",
          "  uniform float lightSize[NUM_STARS];",
          "#endif",
          "#ifdef USE_ATMOSPHERE",
          "  uniform float fg;",
          "  uniform float fg2;",
          "  uniform vec3 v3LightPos;",
          "  varying vec3 v3RayleighColor;",
          "  varying vec3 v3MieColor;",
          "  varying vec3 v3Direction;",
          "  varying float fMiePhase;",
          "  uniform float fExposure;",
          "  uniform float fBias;",
          "#endif",
        ],
      });
      chunks.push({
        after: /vec3 outgoingLight/,
        shader: [
          "outgoingLight = v3RayleighColor + fMiePhase * v3MieColor;",
          "outgoingLight = vec3(1.0, 1.0, 1.0) - exp(-fExposure * outgoingLight);",
          "float lum = 0.2126*outgoingLight.r + 0.7152*outgoingLight.g + 0.0722*outgoingLight.b;",
          "diffuseColor.a = clamp(lum, 0.0, 1.0);",
        ],
      });
      return chunks;
    }
  }

  // ######################################################################
  // ######################################################################

  SkyShader.prototype.stars = null;
  SkyShader.prototype.atmosphere = null;

  // assign class to global namespace
  THRAPP.SkyShader = SkyShader;

  // ######################################################################
  // ######################################################################
})(THREE, THRAPP);
// EO private scope
;
/*
    Copyright 2017-2022 Marcel Greter
    https://www.github.com/mgreter
*/

if (!window.THRAPP) {
  window.THRAPP = {};
}

// private scope
(function (THREE, THRAPP) {
  "use strict";

  // ######################################################################
  // Shader to be used with a ring geometry to render a planetary ring
  // ######################################################################

  class RingShader extends THRAPP.CustomMeshPhysicalMaterial {
    constructor(parameters) {
      super(parameters);
      this.setDefines({
        NUM_ECLIPSERS: 0,
      });
      if (parameters.planetRadius) {
        this.uniforms.planetRadius.value = parameters.planetRadius;
      }
      if (parameters.eclipsers) {
        var eclipsers = parameters.eclipsers;
        if (!Array.isArray(eclipsers)) eclipsers = [eclipsers];
        this.defines["NUM_ECLIPSERS"] = eclipsers.length;
      }
    }
    // EO constructor

    addUniforms(uniforms) {
      super.addUniforms(uniforms);
      uniforms.planetRadius = { type: "f", value: 0 };
    }
    // EO addUniforms

    getVertexChunks() {
      var chunks = super.getVertexChunks();
      //***********************************************
      //***********************************************
      chunks.unshift({
        after: /<common>/,
        shader: [
          "  // The planetary radius",
          "  uniform float planetRadius;",
          "  // Pass world space to fragments",
          "  varying vec3 vertexPos;",
          "  varying vec3 originPos;",
        ],
      });
      chunks.unshift({
        after: /<begin_vertex>/,
        shader: [
          "  // convert from local space to camera space",
          "  vertexPos = vec3(modelViewMatrix * vec4(position, 1.0));",
          "  originPos = vec3(modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0));",
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }
    // EO getVertexChunks

    getFragmentChunks() {
      var chunks = super.getFragmentChunks();
      //***********************************************
      //***********************************************
      chunks.unshift({
        after: /<common>/,
        shader: [
          "  // The planetary radius",
          "  uniform float planetRadius;",
          "  // Pass world space to fragments",
          "  varying vec3 vertexPos;",
          "  varying vec3 originPos;",
          "  // Return distance between line AB and point P",
          "  // Positive if intersection is behind the object.",
          "  // Negative if intersection is in front of the object.",
          "  float lineDistToPoint(vec3 A, vec3 B, vec3 P) {",
          "    // represent the line segment AB as a vector.",
          "    vec3 AB = B - A;",
          "    // I am a bit worried about branch performance?",
          "    // http://stackoverflow.com/a/4176288/1550314",
          "    // if (length(B - P) > length(AB)) return 9e32;",
          "    // calculate front step value to determine on which",
          "    // side the shadow lies (only shade behind object).",
          "    float front = step(0.0, length(B - P) - length(AB));",
          "    // determine the direction of B relative to A.",
          "    vec3 AB_dir = normalize( AB );",
          "    // compute the distance between A and Q using the dot",
          "    // product trick. The first argument is a unit length",
          "    // vector. The second argument is a point *relative to",
          "    // that vector*.",
          "    float AQ_len = dot( AB_dir, P - A );",
          "    // Now that we know the length of AQ, we can compute Q.",
          "    // To do this, think of the following equation as start",
          "    // at A; move along the direction AB_dir by AQ_len units;",
          "    // that position is Q.",
          "    vec3 Q = A + AQ_len * AB_dir;",
          "    // return the length of PQ (negative if front).",
          "    return length( Q - P ) * (-front * 2.0 + 1.0);",
          "  }",
        ],
      });
      chunks.unshift({
        after: /<aomap_fragment>/,
        shader: [
          "  float shaded = 0.0;",
          "#if NUM_POINT_LIGHTS > 0 && NUM_ECLIPSERS > 0",
          THRAPP.StartStaticForLoop("i", "NUM_POINT_LIGHTS"),
          "    // Get camera position in eye/view coordinates",
          "    vec3 light = pointLights[ i ].position;",
          "    // Calculate distance from touch point from planet origin",
          "    float dist = lineDistToPoint(vertexPos, light, originPos);",
          "    shaded += 1.0 - clamp(pow(dist / planetRadius, 64.0), 0.0, 1.0);",
          THRAPP.EndStaticForLoop("i", "NUM_POINT_LIGHTS"),
          "#endif",
          "#if NUM_POINT_LIGHTS > 1",
          "  shaded /= float(NUM_POINT_LIGHTS);",
          "#endif",
        ],
      });
      chunks.unshift({
        after: /vec3 outgoingLight/,
        shader: [
          // Adjust for additional shading
          "outgoingLight *= 1.0 - shaded;",
        ],
      });
      //***********************************************
      //***********************************************
      return chunks;
    }
    // EO getVertexChunks
  }

  // ######################################################################
  // ######################################################################

  RingShader.prototype.planetRadius = null;
  RingShader.prototype.eclipsers = null;

  // assign class to global namespace
  THRAPP.RingShader = RingShader;

  // ######################################################################
  // ######################################################################
})(THREE, THRAPP);
// EO private scope

/* crc: 874F5D0EDFF7211A3C5D08B1DE3D9808 */
