/* autogenerated by webmerge (compile context) */
;
/*
Three.js App Framework (https://github.com/mgreter/three.app)
- Copyright (c) 2017-2023 Marcel Greter (http://github.com/mgreter)
*/;
'use strict';window.THRAPP||(window.THRAPP={});
(function(h,e){function f(l,p,t,u){t=t.shader||"";u=u?1:0;Array.isArray(t)&&(t=t.join("\n"));return l.splice(p,u,t)}function a(l,p){if(l&&l.length)for(var t=0;t<l.length;t++){for(var u=!1,n=l[t],q=0;q<p.length;q++)n.after&&n.after.test(p[q])?(f(p,q+1,n,!1),q+=2,u=!0):n.before&&n.before.test(p[q])?(f(p,q,n,!1),q+=2,u=!0):n.replace&&n.replace.test(p[q])&&(f(p,q,n,!0),q+=1,u=!0);if(!u)throw Error("Shader Chunk not found");}}function b(l,p){l=h.ShaderChunk[p];if(void 0===l)throw Error("Can not resolve #include <"+
p+">");return l.replace(m,b)}function c(l,p,t){class u extends l{constructor(n){n=n||{};super(n);this.type=p;var q=h.ShaderLib[t];this.defines=this.defines||[];var v=q.vertexShader.split(/\n+/);a(this.getVertexChunks(),v);var w=q.fragmentShader.split(/\n+/);a(this.getFragmentChunks(),w);this.vertexShader=this.getVertexShader(v.join("\n"));this.fragmentShader=this.getFragmentShader(w.join("\n"));this.vertexShader=this.vertexShader.replace(m,b);this.fragmentShader=this.fragmentShader.replace(m,b);v=
this.vertexShader.split(/\n+/);a(this.getVertexSubChunks(),v);w=this.fragmentShader.split(/\n+/);a(this.getFragmentSubChunks(),w);this.vertexShader=v.join("\n");this.fragmentShader=w.join("\n");this.uniforms=h.UniformsUtils.merge([n.uniforms,q.uniforms]);this.addUniforms(this.uniforms);this.setValues(n)}setDefines(n){for(var q in n)this.defines[q]=n[q]}getFragmentShader(n){return n}getVertexShader(n){return n}getVertexChunks(){return[]}getFragmentChunks(){return[]}getVertexSubChunks(){return[]}getFragmentSubChunks(){return[]}addUniforms(n){}updateUniforms(){}}
return u}class d extends h.RawShaderMaterial{constructor(l){l=l||{};l.glslVersion="300 es";super(l)}}class g extends h.Mesh{constructor(l,p){super(l,p);p.pbody=this}}const m=/^[ \t]*#include +<([\w\d./]+)>/gm;h.ShaderLib.none={uniforms:{},vertexShader:"",fragmentShader:""};e.CustomMaterial=c;class k extends c(h.ShaderMaterial,"CustomShaderMaterial","basic"){constructor(l){super(l)}}class x extends c(h.MeshBasicMaterial,"CustomMeshBasicMaterial","basic"){constructor(l){super(l)}}class y extends c(h.MeshLambertMaterial,
"CustomMeshLambertMaterial","lambert"){constructor(l){super(l)}}class z extends c(h.MeshPhongMaterial,"CustomMeshPhongMaterial","phong"){constructor(l){super(l)}}class A extends c(h.MeshPhysicalMaterial,"CustomMeshPhysicalMaterial","physical"){constructor(l){super(l)}}e.Mesh=g;e.CustomRawShader=d;e.CustomShaderMaterial=k;e.CustomMeshBasicMaterial=x;e.CustomMeshLambertMaterial=y;e.CustomMeshPhongMaterial=z;e.CustomMeshPhysicalMaterial=A;e.StartStaticForLoop=function(l,p){return[`#if ${p} > 0`,`#if ${p} > 1`,
`  for ( int ${l} = 0; ${l} < ${p}; ++ ${l} ) {`,"#else",`  { int ${l} = 0;`,"#endif\n"].join("\n")};e.EndStaticForLoop=function(l,p){return"  }\n#endif\n"}})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){class f extends e.CustomRawShader{constructor(a){a=a||{};super(a);this.isRawShaderMaterial=!1;this.uniforms.time={type:"f",value:a.time||0};this.uniforms.scale={type:"f",value:a.scale||1};this.uniforms.opacity={type:"f",value:a.opacity||1};this.uniforms.camFadeDist={type:"f",value:a.camFadeDist||5E9};this.uniforms.color={type:"v3",value:new h.Color(a.color||16777215)};this.vertexShader="#include <common>\n#include <logdepthbuf_pars_vertex>\nuniform float time;\nuniform float scale;\nuniform float opacity;\nuniform float camFadeDist;\nuniform vec3 color;\nattribute vec2 attributes;\nvarying vec4 fragColor;\nvoid main() {\n float ra = position.x;\n float dec = position.y;\n float dist = position.z;\n float pm_ra = attributes.x;\n float pm_dec = attributes.y;\n ra += pm_ra * time / 206300000.0;\n dec += pm_dec * time / 206300000.0;\n float x = cos(dec) * cos(ra) * dist * scale;\n float y = cos(dec) * sin(ra) * dist * scale;\n float z = sin(dec) * dist * scale;\n vec4 pos = vec4(x, y, z, 1.0);\n gl_Position = projectionMatrix * modelViewMatrix * pos;\n float camdist = length(cameraPosition.xyz);\n float alpha = 1.0 - smoothstep(0.0, camFadeDist, camdist);\nfragColor = vec4(color.xyz, alpha * opacity);\n#include <logdepthbuf_vertex>\n}";
this.fragmentShader="#include <common>\n#include <logdepthbuf_pars_fragment>\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\nvarying vec4 fragColor;\nvoid main() {\n gl_FragColor = fragColor;\n #include <logdepthbuf_fragment>\n}";if(a.datgui){var b=a.datgui,c=this.uniforms;a.name&&(b=b.addFolder(a.name));b.add(c.scale,"value",0,9).step(.001).name("scale");b.add(c.opacity,"value",0,1).step(.001).name("opacity");b.add(c.camFadeDist,"value",0,5E6).step(.001).name("fade dist");b.addThreeColor(c.color,
"value").name("color")}}}f.prototype.time=null;f.prototype.scale=null;f.prototype.opacity=null;f.prototype.color=null;f.prototype.cameraFadeMin=null;f.prototype.cameraFadeMax=null;e.ConstellationsShader=f})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){class f extends e.CustomRawShader{constructor(a){a=a||{};super(a);this.isRawShaderMaterial=!1;this.defaultAttributeValues=[];this.uniforms.fov={type:"f",value:a.fov||75};this.uniforms.time={type:"f",value:a.time||0};this.uniforms.scale={type:"f",value:a.scale||1};this.uniforms.minMag={type:"f",value:a.minMag||-12};this.uniforms.maxMag={type:"f",value:a.maxMag||28};this.uniforms.dimming={type:"f",value:a.dimming||.9};this.uniforms.opacity={type:"f",value:a.opacity||1};this.uniforms.magFact=
{type:"f",value:a.magFact||25};this.uniforms.magScale={type:"f",value:a.magScale||.35};this.uniforms.sizeScale={type:"f",value:a.sizeScale||1};this.uniforms.fillFactor={type:"f",value:a.fillFactor||1};this.uniforms.fillPower={type:"f",value:a.fillPower||1};this.uniforms.falloff={type:"f",value:a.falloff||206264.80748432202};this.vertexShader="#include <common>\n#include <logdepthbuf_pars_vertex>\nuniform float scale;\nuniform float minMag;\nuniform float maxMag;\nuniform float opacity;\nuniform float magFact;\nuniform float magScale;\nuniform float sizeScale;\nuniform float falloff;\nuniform float dimming;\nuniform float fov;\nuniform float time;\nattribute vec4 attributes;\nvarying vec4 fragColor;\nvarying float camStarDist;\nfloat log10( in float n )\n{\n    // calculate log2 to log10\n    // kLogBase10 = 1.0 / log( 10.0 );\n    return log( n ) * 0.43429448190325176;\n}\nvec4 bv2rgb(float bv, float mag)\n{\n    float t;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    if (bv<-0.4) bv=-0.4;\n    if (bv> 1.95) bv= 1.95;\n    // http://www.vendian.org/mncharity/dir3/starcolor/details.html\n         if ((bv>=-0.40)&&(bv<0.00)) { t=(bv+0.40)/(0.00+0.40); r=0.61+(0.11*t)+(0.1*t*t); }\n    else if ((bv>= 0.00)&&(bv<0.40)) { t=(bv-0.00)/(0.40-0.00); r=0.83+(0.17*t)          ; }\n    else if ((bv>= 0.40)&&(bv<2.10)) { t=(bv-0.40)/(2.10-0.40); r=1.00                   ; }\n         if ((bv>=-0.40)&&(bv<0.00)) { t=(bv+0.40)/(0.00+0.40); g=0.70+(0.07*t)+(0.1*t*t); }\n    else if ((bv>= 0.00)&&(bv<0.40)) { t=(bv-0.00)/(0.40-0.00); g=0.87+(0.11*t)          ; }\n    else if ((bv>= 0.40)&&(bv<1.60)) { t=(bv-0.40)/(1.60-0.40); g=0.98-(0.16*t)          ; }\n    else if ((bv>= 1.60)&&(bv<2.00)) { t=(bv-1.60)/(2.00-1.60); g=0.82         -(0.5*t*t); }\n         if ((bv>=-0.40)&&(bv<0.40)) { t=(bv+0.40)/(0.40+0.40); b=1.00                   ; }\n    else if ((bv>= 0.40)&&(bv<1.50)) { t=(bv-0.40)/(1.50-0.40); b=1.00-(0.47*t)+(0.1*t*t); }\n    else if ((bv>= 1.50)&&(bv<1.94)) { t=(bv-1.50)/(1.94-1.50); b=0.63         -(0.6*t*t); }\n    return vec4(r, g, b, mag);\n}\nvoid main() {\n float ra = position.x;\n float dec = position.y;\n float dist = position.z;\n float pm_ra = attributes.x;\n float pm_dec = attributes.y;\n ra += pm_ra * time / 206300000.0;\n dec += pm_dec * time / 206300000.0;\n float x = cos(dec) * cos(ra) * dist * scale;\n float y = cos(dec) * sin(ra) * dist * scale;\n float z = sin(dec) * dist * scale;\n vec4 pos = vec4(x, y, z, 1.0);\n gl_Position = projectionMatrix * modelViewMatrix * pos;\n fragColor = bv2rgb(attributes.a, dimming);\n float camZoomDist = length(cameraPosition);\n camStarDist = distance(cameraPosition / falloff, pos.xyz);\n float mag = position.a;\n float vmag = mag - 5.0 + 5.0 * log10(camStarDist);\n gl_PointSize = magFact * exp(- magScale * vmag);\n gl_PointSize *= sizeScale;\n gl_PointSize = clamp(gl_PointSize, 0.0, 75.0);\n gl_PointSize *= fov;\n gl_PointSize += clamp(camZoomDist / 50000000.0, 0.2, 3.5);\n fragColor.a *= clamp(camStarDist * 1.0e5, 0.0, 1.0);\n fragColor.a -= smoothstep(minMag, maxMag, vmag);\n fragColor.a *= smoothstep(0.0, 3.0, pow(gl_PointSize, 0.5));\n fragColor.a *= opacity;\n gl_Position = projectionMatrix * modelViewMatrix * pos;\n #include <logdepthbuf_vertex>\n}";
this.fragmentShader="out highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#include <logdepthbuf_pars_fragment>\nuniform float fillFactor;\nuniform float fillPower;\nuniform float dimming;\nvarying float camStarDist;\nvarying vec4 fragColor;\nvoid main() {\n vec2 uv = gl_PointCoord - vec2(0.5, 0.5);\n float dist = 1.0 - length(uv) * 2.0;\n dist = smoothstep(0.0, 1.0, pow(dist, 1.25));\n dist = fillFactor * pow(dist, fillPower);\n #ifdef HAS_SPIKES\n dist = max(dist, 1.0 - max(abs(uv.x), abs(uv.y)) * 2.75);\n dist = max(dist, (1.0 - abs(uv.x * 2.0)) * (1.0 - abs(uv.y * 2.0)));\n #endif\n gl_FragColor = fragColor * dist;\n #include <logdepthbuf_fragment>\n}";
this.vertexFilter=this.fragmentFilter=function(d){return d.replace(/attribute vec3 position;/g,"attribute vec4 position;").replace(/attribute vec[23] (?:normal|uv);/g,"")};if(a.datgui){var b=a.datgui,c=this.uniforms;a.name&&(b=b.addFolder(a.name));b.add(c.scale,"value",-24,64).step(.001).name("scale");b.add(c.minMag,"value",-24,64).step(.001).name("minMag");b.add(c.maxMag,"value",-24,64).step(.001).name("maxMag");b.add(c.opacity,"value",0,1).step(.001).name("opacity");b.add(c.magFact,"value",0,80).step(.001).name("magFact");
b.add(c.magScale,"value",0,5).step(.001).name("magScale");b.add(c.sizeScale,"value",0,40).step(.001).name("sizeScale");b.add(c.fillFactor,"value",.5,2).step(.001).name("fillFactor");b.add(c.fillPower,"value",.25,4).step(.001).name("fillPower");b.add(c.falloff,"value",0,5E5).step(.001).name("falloff");b.add(c.dimming,"value",0,4).step(.001).name("dimming")}}addUniforms(a){super.addUniforms(a)}updateUniforms(){super.updateUniforms()}}f.prototype.time=null;f.prototype.fov=null;f.prototype.scale=null;
f.prototype.minMag=null;f.prototype.maxMag=null;f.prototype.opacity=null;f.prototype.magFact=null;f.prototype.magScale=null;f.prototype.sizeScale=null;e.FirmamentShader=f})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){class f extends e.CustomRawShader{constructor(a){super(a);this.defines.USE_LOGDEPTHBUF=1;this.defines.USE_LOGDEPTHBUF_EXT=1;this.isRawShaderMaterial=!0;this.uniforms.time={type:"f",value:a.time||0};this.uniforms.scale={type:"f",value:a.scale||1};this.uniforms.lucency={type:"f",value:a.lucency||.75};this.uniforms.attenuate={type:"f",value:a.attenuate||0};this.uniforms.trailStart={type:"f",value:a.trailStart||0};this.uniforms.trailLength={type:"f",value:a.trailLength||1};null!=this.defines.LAPLACE_PLANE&&
(this.uniforms.laplaceEpoch={type:"f",value:a.laplaceEpoch||0});this.vertexShader="\n\n\n\n        #define varying out\n\n        #define attribute in\n\n        out highp vec4 pc_fragColor;\n\n        #define gl_FragColor pc_fragColor\n\n        #define gl_FragDepthEXT gl_FragDepth\n\n\n\n        precision highp float;\n\n        precision highp int;\n\n        #define HIGH_PRECISION\n\n        #define GAMMA_FACTOR 2\n\n        uniform mat4 viewMatrix;\n\n        uniform vec3 cameraPosition;\n\n        uniform bool isOrthographic;\n\n        uniform mat4 modelMatrix;\n\n        uniform mat4 modelViewMatrix;\n\n        uniform mat4 projectionMatrix;\n\n        uniform mat3 normalMatrix;\n\n\n\n        // ***************************************************************\n\n        // orbit.vert\n\n        // ***************************************************************\n\n        #include <common>\n\n        #include <logdepthbuf_pars_vertex>\n\n\n\n        // Gravitational Constant\n\n        #ifdef USE_GLOBAL_GM\n\n        uniform float GM;\n\n        #else\n\n        attribute float GM;\n\n        #endif\n\n        \n\n        // Gravitational Constant\n\n        #ifdef USE_GLOBAL_EPOCH\n\n        uniform float epoch;\n\n        #else\n\n        attribute float epoch;\n\n        #endif\n\n\n\n        // time in julian days\n\n        // uniform float time;\n\n        uniform float time;\n\n        \n\n        //uniform float itime;\n\n        //uniform float ftime;\n\n        \n\n        // global lucency value\n\n        uniform float lucency;\n\n        uniform float attenuate;\n\n        \n\n        // scale the positions\n\n        uniform float scale;\n\n        uniform float trailLength;\n\n        uniform float trailStart;\n\n        \n\n        // from interleaved buffer\n\n        //attribute vec2 epoch;\n\n        attribute vec3 color;\n\n        attribute vec3 l_orbitals;\n\n        attribute vec3 h_orbitals;\n\n        attribute float rotate;\n\n\n\n        // dynamic laplace plane\n\n        #ifdef LAPLACE_PLANE\n\n        attribute vec4 laplace;\n\n        uniform float laplaceEpoch;\n\n        #endif\n\n\n\n        attribute vec2 precession;\n\n        \n\n        // position around ellipse\n\n        attribute float position;\n\n        attribute float position3;\n\n\n\n        // pass to fragment shader\n\n        varying vec4 fragColor;\n\n\n\n// ***************************************************************\n\n// calculate position from VSOP elements (alkhqp)\n\n// this function is adapted from VSOP2013.f\n\n// ***************************************************************\n\n#ifdef ELEMENTS_VSOP\n\n\n\n\tvec3 orb2cart(float arc, float a, float l, float k, float h, float q, float p)\n\n\t{\n\n\n\n\t\tfloat fi = sqrt(1.0 - k*k - h*h);\n\n\t\tfloat ki = sqrt(1.0 - q*q - p*p);\n\n\t\tfloat u = 1.0 / (1.0 + fi);\n\n\t\tvec2 z = vec2(k, h);\n\n\n\n\t\tfloat ex = length(z);\n\n\t\tfloat ex2 = ex * ex;\n\n\t\tfloat ex3 = ex2 * ex;\n\n\n\n    float n = sqrt(GM / a / a / a);\n\n    // orbit._n = sqrt(orbit._G / pow(orbit._a, 3.0));\n\n\t\tfloat gl = mod(l + (time - epoch) * n + arc, PI2);\n\n\t\tfloat gm = gl - atan(h, k);\n\n\t\tfloat e = gl + (ex - 0.125 * ex3) * sin(gm)\n\n\t\t\t\t+ 0.5 * ex2 * sin(2.0 * gm)\n\n\t\t\t\t+ 0.375 * ex3 * sin(3.0 * gm);\n\n\n\n\t\tvec2 z3;\n\n\t\tvec2 zteta;\n\n\t\tfloat rsa = 0.0;\n\n\n\n\t\tfor (int count = 0; count < 10; count ++) {\n\n\t\t\tzteta.x = cos(e);\n\n\t\t\tzteta.y = sin(e);\n\n\t\t\tz3.x = k*zteta.x+h*zteta.y;\n\n\t\t\tz3.y = k*zteta.y-h*zteta.x;\n\n\t\t\tfloat dl = gl - e + z3.y;\n\n\t\t\trsa = 1.0 - z3.x;\n\n\t\t\t// not sure if the branching is more expensive\n\n\t\t\t// what we gain from not running the whole loop\n\n\t\t\tif (abs(dl) < 1e-15) break;\n\n\t\t\te += dl / rsa;\n\n\t\t}\n\n\n\n\t\t// optimized for performance\n\n\t\tfloat ztox = (zteta.x - z.x + z.y * u * z3.y) / rsa;\n\n\t\tfloat ztoy = (zteta.y - z.y - z.x * u * z3.y) / rsa;\n\n\n\n\t\tfloat r = a * rsa;\n\n\t\tfloat m = p * ztox - q * ztoy;\n\n\n\n\t\treturn vec3(\n\n\t\t\tr * (ztox - 2.0 * p * m),\n\n\t\t\tr * (ztoy + 2.0 * q * m),\n\n\t\t\t-2.0 * r * ki * m\n\n\t\t);\n\n\n\n\t}\n\n\n\n// ***************************************************************\n\n// calculate position from orbital elements\n\n// ***************************************************************\n\n#else\n\n\n\n\tvec3 orb2cart(float arc, float e, float a, float i, float O, float w, float M0)\n\n\t{\n\n\n\n\t\t// ToDo: time should be in double precision\n\n\t\t// needs two uniforms: 32ipart and 32fpart\n\n\n\n\t\t// Calculate mean anomaly M(t)\n\n\t\t// with u for sun as central body\n\n\t\tfloat dt = time - epoch; // + 0.5 / 365.25;\n\n\n\n    // dynamic laplace plane\n\n\t\t#ifdef LAPLACE_PLANE\n\n\t\t\t// adjust for laplace precession\n\n\t\t\t//float rot_O = (time - laplaceEpoch) * laplace.z;\n\n\t\t\t// rot_O -= (laplaceEpoch * laplace.z);\n\n\t\t\t//float rot_W = (time - laplaceEpoch) * laplace.w;\n\n\t\t\t// rot_W -= (laplaceEpoch * laplace.w);\n\n\t\t\t// rotate into laplace plane\n\n\t\t\t//O -= laplace.x;\n\n      //w -= laplace.y;\n\n      //i -= laplace.z;\n\n\n\n\t\t\t//w += rot_W;\n\n\t\t#endif\n\n\n\n    O += dt * precession.x;\n\n    w += dt * precession.y;\n\n\n\n\t\t// calculate orbital period factor\n\n\t\tfloat n = sqrt(pow(a, 3.0) / GM);\n\n\n\n\t\t// M = CYCLE(orbit._n * (dt - orbit._T - epoch))\n\n\t\tfloat M = M0 + dt / n;\n\n    // M += 0.1758;\n\n\n\n\n\n\t\t// solve the kepler equation\n\n\t\t// M(t) = E(t) - s * sin(E)\n\n\t\t// for the eccentric anomaly E(t)\n\n\t\t// this must be done iteratively\n\n\t\tfloat E = mod(M, PI2);\n\n\n\n\t\t// M = orbit._n * (dt - orbit._T - epoch);\n\n\n\n\t\t// we can either add arc first, to adjust\n\n\t\t// the offset with the actual speed the\n\n\t\t// object would travel. But this gives\n\n\t\t// a bad distribution of points on the\n\n\t\t// ellipsis. Comet icarus would have a\n\n\t\t// very rough bump on the periapsis.\n\n\n\n\t\t// Newton-Raphson method to solve\n\n\t\t// f(E) = M - E + e * sin(E) = 0\n\n\t\tfor (int it = 0; it < 20; ++it) {\n\n\t\t\tfloat f = M - E + e * sin(E);\n\n\t\t\tfloat dfdE = e * cos(E) - 1.0;\n\n\t\t\tfloat dE = f / dfdE;\n\n\t\t\tE -= dE; // next iteration\n\n\t\t}\n\n\n\n\t\t// add offset now to distribute\n\n\t\t// the vertices accordingly\n\n\t\tE = mod(E, PI2) + arc;\n\n\t\t// E = 4.769749851054432 + arc;\n\n\n\n\t\t// Obtain the true anomaly vector(t)\n\n\t\tfloat v1 = sqrt(1.0 + e) * sin(E/2.0);\n\n\t\tfloat v2 = sqrt(1.0 - e) * cos(E/2.0);\n\n\t\tfloat m = 2.0 * atan( v1, v2 );\n\n\n\n\t\t// Distance to true anomaly position\n\n\t\tfloat r = a * (1.0 - e * cos(E));\n\n\n\n\t\t// Factors for projection\n\n\t\tfloat px = r * cos(m);\n\n\t\tfloat py = r * sin(m);\n\n\n\n\t\t// Precalculations\n\n\t\tfloat cosW = cos(w);\n\n\t\tfloat cosO = cos(O);\n\n\t\tfloat cosI = cos(i);\n\n\t\tfloat sinW = sin(w);\n\n\t\tfloat sinO = sin(O);\n\n\t\tfloat sinI = sin(i);\n\n\n\n\t\tfloat sinWcosO = sinW*cosO;\n\n\t\tfloat sinWsinO = sinW*sinO;\n\n\t\tfloat cosWcosO = cosW*cosO;\n\n\t\tfloat cosWsinO = cosW*sinO;\n\n\n\n\t\tfloat FxX = (cosW*cosO - sinW*sinO*cosI);\n\n\t\tfloat FyX = (cosW*sinO + sinW*cosO*cosI);\n\n\t\tfloat FxY = (cosW*sinO*cosI + sinW*cosO);\n\n\t\tfloat FyY = (cosW*cosO*cosI - sinW*sinO);\n\n\t\tfloat FzX = (sinW*sinI);\n\n\t\tfloat FzY = (cosW*sinI);\n\n\n\n\t\t// calculate cartesian coordinates\n\n\t\tfloat x = + px * FxX - py * FxY;\n\n\t\tfloat y = + px * FyX + py * FyY;\n\n\t\tfloat z = + px * FzX + py * FzY;\n\n\n\n\t\tvec3 coord = vec3(x, y, z);\n\n\n\n\t\t// dynamic laplace plane\n\n\t\t#ifdef LAPLACE_PLANE\n\n\n\n\t\t\t// laplace precession\n\n\t\t\tfloat node = (laplace.x + PI * 0.5);\n\n\t\t\tfloat incl = (PI * 0.5 - laplace.y);\n\n\n\n\t\t\tmat3 rotX = mat3(\n\n\t\t\t\t1.0, 0.0, 0.0,\n\n\t\t\t\t0.0, cos(incl), sin(incl),\n\n\t\t\t\t0.0, - sin(incl), cos(incl)\n\n\t\t\t);\n\n//\n\n//\t\t\tmat3 rotY = mat3(\n\n//\t\t\t\tcos(ay), 0.0, sin(ay),\n\n//\t\t\t\t0.0, 1.0, 0.0,\n\n//\t\t\t\t- sin(ay), 0.0, cos(ay)\n\n//\t\t\t);\n\n//\n\n      mat3 rotZ = mat3(\n\n\t\t\t\tcos(node), sin(node), 0.0,\n\n\t\t\t\t- sin(node), cos(node), 0.0,\n\n\t\t\t\t0.0, 0.0, 1.0\n\n\t\t\t);\n\n//return coord;\n\n\t\t\treturn rotZ * rotX * coord;\n\n\t\t\t// return coord * rotX * rotZ;\n\n\n\n\t\t#else\n\n\n\n\t\t\treturn vec3(\n\n\t\t\t\tx, y, z\n\n\t\t\t);\n\n\n\n\t\t#endif\n\n\n\n\n\n\t\t// Get derivates for velocity\n\n\t\t// float vf = sqrt(GM * a) / r;\n\n\t\t// float vx = vf * - sin(E);\n\n\t\t// float vy = vf * sqrt(1.0 - e*e) * cos(E);\n\n\t\t// Calculate velocity\n\n\t\t// return vec3(\n\n\t\t// \t+ vx * FxX - vy * FxY,\n\n\t\t// \t+ vx * FyX + vy * FyY,\n\n\t\t// \t+ vx * FzX + vy * FzY,\n\n\t\t// );\n\n\n\n\t}\n\n\n\n#endif\n\n\n\n// ***************************************************************\n\n// ***************************************************************\n\n\n\nvoid main()\n\n{\n\n\n\n\t// attenuate the more away from current position\n\n\t// fragColor = vec4(color, 0.35 - 0.275 * pow(abs(position), .1));\n\n\n\n    fragColor = vec4(color, 1.0); // vec4(color, (1.0 - position) * 0.75 + 0.25);\n\n\n\n\t// attenuate the orbit to create a trail (position is linear from 0 to 1)\n\n\tfragColor.a *= (pow(exp(-position * attenuate), 2.0)) * lucency;\n\n\n\n    float foo = 1.0 + smoothstep(0.9, 1.0, position) * (step(attenuate, 0.0) - 1.0);\n\n\n\n    fragColor.a *= foo;\n\n\n\n    //fragColor.a *= (1.0 - position);\n\n\n\n\t// calculate the actual position\n\n\tvec3 pos = orb2cart((position * - trailLength) * PI2 + (trailStart) * PI2,\n\n\t\tl_orbitals[0], l_orbitals[1], l_orbitals[2],\n\n\t\th_orbitals[0], h_orbitals[1], h_orbitals[2]\n\n\t);\n\n\n\n\t// calculate the final world position to be drawn\n\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n\n\n\n\t// THREE.ShaderChunk[ 'logdepthbuf_vertex'\n\n\t#include <logdepthbuf_vertex>\n\n\n\n}\n\n\n\n// ***************************************************************\n\n// ***************************************************************\n\n\n\n\n\n        ";
this.fragmentShader="\n\n        #define varying in\n\n        out highp vec4 pc_fragColor;\n\n        #define gl_FragColor pc_fragColor\n\n        #define gl_FragDepthEXT gl_FragDepth\n\n\n\n        // ***************************************************************\n\n        // orbit.frag\n\n        // ***************************************************************\n\n        precision highp float;\n\n        precision highp int;\n\n        #include <common>\n\n        #include <logdepthbuf_pars_fragment>\n\n        \n\n        uniform float lucency;\n\n        varying vec4 fragColor;\n\n        \n\n        // ***************************************************************\n\n        // ***************************************************************\n\n\n\n        void main()\n\n        {\n\n\n\n            // passed from vertex shader\n\n            gl_FragColor = fragColor;\n\n        \n\n            // we use translucency, since this is less error prone\n\n            // in case you forgot to define opacity (default is 0)\n\n            // gl_FragColor.a *= 1.0 - lucency;\n\n        \n\n             // gl_FragColor.a = max(gl_FragColor.a, 0.0);\n\n            \n\n        \n\n            // THREE.ShaderChunk[ 'logdepthbuf_fragment' ]\n\n            #include <logdepthbuf_fragment>\n\n\n\n        }\n\n        \n\n        // ***************************************************************\n\n        // ***************************************************************\n\n        \n\n        ";
if(a.datgui){var b=a.datgui,c=this.uniforms;a.name&&(b=b.addFolder(a.name));b.add(c.lucency,"value",0,1).step(.001).name("lucency");b.add(c.attenuate,"value",0,9).step(.001).name("attenuate");b.add(c.trailStart,"value",0,1).step(.001).name("trailStart");b.add(c.trailLength,"value",-1,1).step(.001).name("trailLength")}}addOrbital(a){}addUniforms(a){super.addUniforms(a)}updateUniforms(){super.updateUniforms()}getVertexChunks(){var a=super.getVertexChunks();a.push({after:/<common>/,shader:[]});a.push({before:/<begin_vertex>/,
shader:[]});return a}getFragmentChunks(){var a=super.getFragmentChunks();a.push({after:/<common>/,shader:[]});a.push({before:/<aomap_fragment>/,shader:[]});a.push({after:/<aomap_fragment>/,shader:[]});a.push({after:/vec3 outgoingLight/,shader:[]});return a}}f.prototype.lucency=null;f.prototype.attenuate=null;f.prototype.trailLength=null;f.prototype.trailStart=null;f.prototype.trailEnd=null;e.OrbitalsShader=f})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
THRAPP.BaseMaterial=THRAPP.BaseMaterial||THRAPP.CustomMeshPhysicalMaterial;
(function(h,e){class f extends e.BaseMaterial{constructor(a){super(a);this.setDefines({NUM_STARS:0,NUM_ECLIPSERS:0});this.stars=[];this.eclipsers=[];this.addStar(a.stars||[]);this.addEclipser(a.eclipsers||[]);this.uniforms.bodyRadius.value=a.radius||0;null!=a.laserSize&&(this.defines.USE_ECLIPSE_LASER="",this.uniforms.laserSize.value=a.laserSize);this.pbody=a.pbody||null;this.localWorldInverse=new h.Matrix4}presetValues(){this.pbody=null}addStar(a){Array.isArray(a)||(a=[a]);for(var b=0;b<a.length;b++)this.stars.push(a[b]),
this.uniforms.lightPos.value.push(new h.Vector3),this.uniforms.lightSize.value.push(2*(a[b].radius||0));this.defines.NUM_STARS!=this.stars.length&&(this.defines.NUM_STARS=this.stars.length,this.needsUpdate=!0)}addEclipser(a){Array.isArray(a)||(a=[a]);for(let b=0;b<a.length;b++)this.eclipsers.push(a[b]),this.uniforms.eclipserPos.value.push(new h.Vector3),this.uniforms.eclipserSize.value.push(2*(a[b].radius||0));this.defines.NUM_ECLIPSERS!=this.eclipsers.length&&(this.defines.NUM_ECLIPSERS=this.eclipsers.length,
this.needsUpdate=!0)}addUniforms(a){super.addUniforms(a);a.eclipserSize={type:"fv1",value:[]};a.eclipserPos={type:"v3v",value:[]};a.lightSize={type:"fv1",value:[]};a.lightPos={type:"v3v",value:[]};a.laserSize={type:"f",value:5E-7};a.bodyRadius={type:"f",value:5E-7};a.localScale={type:"v3",value:new h.Vector3(1,1,1)}}updateUniforms(){var a=this.uniforms,b=this.eclipsers,c=this.stars;super.updateUniforms();if(this.pbody){this.pbody.updateMatrix();this.localWorldInverse.copy(this.pbody.matrixWorld).invert();
var d=this.pbody.scale.x,g=this.pbody.scale.y;const m=this.pbody.scale.z,k=this.localWorldInverse.elements;k[0]*=d;k[4]*=d;k[8]*=d;k[12]*=d;k[1]*=g;k[5]*=g;k[9]*=g;k[13]*=g;k[2]*=m;k[6]*=m;k[10]*=m;k[14]*=m;a.localScale.value.copy(this.pbody.scale)}for(d=0;d<b.length;d+=1)g=a.eclipserPos.value[d],g.setFromMatrixPosition(b[d].matrixWorld),g.applyMatrix4(this.localWorldInverse);for(d=0;d<c.length;d+=1)g=a.lightPos.value[d],g.setFromMatrixPosition(c[d].matrixWorld),g.applyMatrix4(this.localWorldInverse)}debug(a,
b){var c=new h.Vector3,d=this.uniforms.lightPos.value,g=this.uniforms.lightSize.value,m=this.uniforms.eclipserPos.value,k=this.uniforms.eclipserSize.value,x=this.uniforms.bodyRadius.value;console.log("Body Radius: ",x);console.log("Light[",a,"] - size: ",g[a],", pos: ",d[a]);console.log("Eclipser[",b,"] - size: ",k[b],", pos: ",m[b]);c=c.copy(d[a]).sub(m[b]).length();m=m[b].length()-x;a=g[a]/c*m;console.log("Umbra(outer): ",k[b]/c*(c+m)-a,", Penumbra(core): ",a)}getVertexChunks(){var a=super.getVertexChunks();
a.push({after:/<common>/,shader:["  // Local vertex position","  varying vec3 vertexPos;","  uniform vec3 localScale;"]});a.push({before:/<begin_vertex>/,shader:[" // Pass vertex position to fragments","  vertexPos = position * localScale;"]});return a}getFragmentChunks(){var a=super.getFragmentChunks();a.push({after:/<common>/,shader:"  uniform float bodyRadius;,  // Local vertex in world scale,  varying vec3 vertexPos;,#ifdef USE_ECLIPSE_LASER,  uniform float laserSize;,#endif,#if NUM_STARS > 0,  uniform vec3 lightPos[NUM_STARS];,  uniform float lightSize[NUM_STARS];,#endif,#if NUM_ECLIPSERS > 0,  uniform vec3 eclipserPos[NUM_ECLIPSERS];,  uniform float eclipserSize[NUM_ECLIPSERS];,#endif".split(",")});
a.push({after:/<common>/,shader:["  float lineDistToPoint(vec3 A, vec3 B, vec3 P) {","    // represent the line segment AB as a vector.","    vec3 AB = B - A;","    // determine the direction of B relative to A.","    vec3 AB_dir = normalize( AB );","    // compute the distance between A and Q using the dot","    // product trick.  The first argument is a unit length","    // vector.  The second argument is a point *relative to","    // that vector*.","    float AQ_len = dot( AB_dir, P - A );","    // Now that we know the length of AQ, we can compute Q.",
"    // To do this, think of the following equation as start","    // at A; move along the direction AB_dir by AQ_len units;","    // that position is Q.","    vec3 Q = A + AQ_len * AB_dir;","    // return the length of PQ.","    return length( Q - P );","  }"]});a.push({before:/<aomap_fragment>/,shader:["float shadows = 1.0;"]});a.push({after:/<aomap_fragment>/,shader:["#if NUM_STARS > 0 && NUM_ECLIPSERS > 0","  float starIntensity[NUM_STARS];","  #ifdef USE_ECLIPSE_LASER","    vec3 laserDot = vec3(0.0, 0.0, 0.0);",
"    vec3 laserCol = vec3(1.0, 0.0, 0.0);","  #endif",e.StartStaticForLoop("n","NUM_ECLIPSERS"),e.StartStaticForLoop("i","NUM_STARS"),"      // Get light position from passed uniform. There seems to be other way","      // to get these via `pointLings[n].position`, but unsure how exactly.","      // Get closest distance from the vertex point to the light ray.","      // We want to do this calculation in world space, but for best accuracy","      // we need to get the vertex point into local space. We simply do that",
"      // by translating all points into local space by subtracting the world","      // position of the parent system (moving zero coordinate). Which would be:","      // float dist = lineDistToPoint(eclipserPos[n], lightPos[i], vertexWorldPos - off);","      // The last subtraction is problematic, as it looses a lot of precision.","      // Instead we provide a uniform with world position of the parent frame.","      // This probably ignores some scaling and maybe some rotations, but allows","      // us to do the subtraction on values that are themselves rather big.",
"      // vec3 light = (vec4(pointLights[ i ].position, 1.0) * viewMatrix).xyz;","      float behind = step(0.0, length(vertexPos - lightPos[i]) - length(lightPos[i]));","      float dist = lineDistToPoint(eclipserPos[n], lightPos[i], vertexPos) + behind * 9e32;","      // inner umbra and quadratic falloff for outer penumbra","      // calculate umbra and penumbra from radii and distances","      // http://www.opticiansfriend.com/articles/equations.html#Shadows","      // Length from light source to L1 & Length from L1 to Umbra",
"      float L1 = length(lightPos[i] - eclipserPos[n]);","      float L2 = length(eclipserPos[n]) - bodyRadius;","      float D1 = lightSize[i];","      float D2 = eclipserSize[n];","      float P = D1 / L1 * L2;","      float U = D2 / L1 * (L1 + L2) - P;","      U = max(U, 0.0); P = max(P, U);","      starIntensity[i] += pow(smoothstep(U*.97, P, dist), 0.5);","      #ifdef USE_ECLIPSE_LASER","        laserDot += smoothstep(laserSize, laserSize*.2, dist) * laserCol;","      #endif",e.EndStaticForLoop("i",
"NUM_STARS"),e.EndStaticForLoop("n","NUM_ECLIPSERS"),"  float globalIntensity = 0.0;",e.StartStaticForLoop("m","NUM_STARS"),"    starIntensity[m] /= float(NUM_ECLIPSERS);","    globalIntensity += starIntensity[m] / float(NUM_STARS);",e.EndStaticForLoop("m","NUM_STARS"),"  shadows *= pow(clamp(globalIntensity, 0.0, 1.0), 2.0);","#endif"]});a.push({after:/vec3 outgoingLight/,shader:"outgoingLight *= clamp(0.0, 1.0, shadows);{#if NUM_STARS > 0 && NUM_ECLIPSERS > 0{  #ifdef USE_ECLIPSE_LASER{    outgoingLight = clamp(outgoingLight + laserDot, 0.0, 1.0);{  #endif{#endif".split("{")});
return a}}f.prototype.pbody=null;f.prototype.radius=null;f.prototype.stars=null;f.prototype.eclipsers=null;f.prototype.laserSize=null;e.EclipseShader=f})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){var f=new h.Matrix4;class a extends e.EclipseShader{constructor(b){super(b);this.setDefines({NUM_RINGS:0});this.rings=[];this.addRing(b.rings||[]);b.nightMap&&(this.defines.USE_UV="",this.defines.USE_NIGHT_MAP="",this.uniforms.nightMap.value=b.nightMap);b.ringMap&&(this.defines.USE_RING_MAP="",this.uniforms.ringMap.value=b.ringMap)}addRing(b){Array.isArray(b)||(b=[b]);for(var c=0;c<b.length;c++){this.rings.push(b[c]);var d=new h.Vector2(b[c].innerRadius||0,b[c].outerRadius||0);this.uniforms.ringRadii.value.push(d);
this.uniforms.ringNorm.value.push(new h.Vector3);this.uniforms.ringWMat4.value.push(b[c].matrixWorld||new h.Matrix4)}this.defines.NUM_RINGS+=b.length;this.needsUpdate=!0}updateUniforms(){var b=this.rings,c=this.uniforms;super.updateUniforms();this.pbody&&f.copy(this.pbody.matrixWorld).invert();for(var d=0;d<b.length;d+=1)c.ringNorm.value[d].set(0,0,1).applyMatrix4(b[d].matrixWorld).applyMatrix4(f)}addUniforms(b){super.addUniforms(b);b.nightMap={type:"t",value:null};b.ringMap={type:"t",value:null};
b.ringWMat4={type:"vm4",value:[]};b.ringNorm={type:"v3v",value:[]};b.ringRadii={type:"v2v",value:[]}}getVertexChunks(){return super.getVertexChunks()}getFragmentChunks(){var b=super.getFragmentChunks();b.push({after:/<common>/,shader:["#ifdef USE_NIGHT_MAP","  uniform sampler2D nightMap;","#endif"]});b.push({after:/vec3 outgoingLight/,shader:["#ifdef USE_NIGHT_MAP","  float hasLight = 0.0;",e.StartStaticForLoop("i","NUM_STARS"),"    float girrad = dot(-normalize(vertexPos), normalize(lightPos[i]));",
"    hasLight += pow(1.0 - clamp(girrad, 0.0, 1.0), 4.0);","#ifdef DEBUG_DAYLIGHT_TERMINATOR","    if (girrad < 0.01 && girrad > 0.0) outgoingLight.r = 1.0; ","#endif",e.EndStaticForLoop("i","NUM_STARS"),"  outgoingLight += texture2D(nightMap, vUv).xyz * clamp(1.0 - hasLight, 0.0, 1.0);","#else","#endif"]});b.push({after:/<common>/,shader:"#ifdef USE_RING_MAP,  uniform sampler2D ringMap;,#endif,#if NUM_RINGS > 0,  uniform vec2 ringRadii[NUM_RINGS];,  uniform mat4 ringWMat4[NUM_RINGS];,  uniform vec3 ringNorm[NUM_RINGS];,#endif".split(",")});
b.push({after:/<aomap_fragment>/,shader:["float ringShadows = 1.0;","#if NUM_RINGS > 0 && NUM_STARS > 0","  float ringShadow[NUM_STARS];",e.StartStaticForLoop("n","NUM_RINGS"),"    vec3 axisWorldDir = normalize(ringNorm[n]);","    ringShadow[n] = 0.0;",e.StartStaticForLoop("i","NUM_STARS"),"      // Intersect the vertex point with the ring plane and return distance to center.","      // From there we can calculate if it lies between inner and outer radius.","      float d = dot(-vertexPos, axisWorldDir) / dot(lightPos[i], axisWorldDir);",
"      vec3 p = vertexPos + lightPos[i] * d;","      // Check if distance is between inner and outer radius","      float range = (ringRadii[n].y - ringRadii[n].x) / 2.0;","      float dist = abs(length(p) - ringRadii[n].x - range);","      float fact = 1.0 - clamp(pow(dist / range, 8.0), 0.0, 1.0);","      fact *= step(0.0, d);","#ifdef USE_RING_MAP","        vec2 rUv = vec2(0.5, 1.0 - (length(p) - ringRadii[n].x) / range / 2.0);","        vec4 tex = texture2D(ringMap, rUv);","        // Calculate luminance at the texture position",
"        float lum = 0.2126*tex.r + 0.7152*tex.g + 0.0722*tex.b;","        ringShadow[n] += fact * pow(lum, 0.5) * pow(tex.a, 0.5);","#else","        ringShadow[n] += fact;","#endif",e.EndStaticForLoop("i","NUM_STARS"),e.EndStaticForLoop("n","NUM_RINGS"),e.StartStaticForLoop("i","NUM_RINGS"),"    ringShadows -= ringShadow[i] / float(NUM_STARS);",e.EndStaticForLoop("i","NUM_RINGS"),"  shadows *= ringShadows;","#endif"]});return b}}a.prototype.nightMap=null;a.prototype.ringMap=null;e.PlanetShader=a})(THREE,
THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){new h.Matrix4;class f extends e.PlanetShader{constructor(a){super(a);this.setDefines({USE_GROUNDSHADER:1,NUM_SAMPLES:16});if(!a.camera)throw"Camera missing";this.camera=a.camera;if(a.atmosphere){a=a.atmosphere;var b=this.uniforms;a.G=a.G||-.95;a.Kr=a.Kr||.0025;a.Km=a.Km||.001;a.ESun=a.ESun||20;a.bias=a.bias||.5;a.exposure=a.exposure||2.5;a.scaleDepth=a.scaleDepth||.25;a.scaleHeight=a.scaleHeight||1.025;a.innerRadius=a.innerRadius||0;var c=a.wavelength;b.v3InvWavelength.value.set(1/
Math.pow(c.r,4),1/Math.pow(c.g,4),1/Math.pow(c.b,4));c=a.G;b.fg.value=c;b.fg2.value=c*c;c=a.Kr;var d=a.Km,g=a.ESun;b.fKrESun.value=c*g;b.fKmESun.value=d*g;b.fKr4PI.value=4*c*Math.PI;b.fKm4PI.value=4*d*Math.PI;c=a.scaleDepth;d=a.innerRadius;g=d+a.height;b.fBias.value=a.bias;b.fExposure.value=a.exposure;b.fScale.value=1/(g-d);b.fScaleDepth.value=c;b.fOuterRadius.value=g;b.fInnerRadius.value=d;b.fOuterRadius2.value=g*g;b.fInnerRadius2.value=d*d}}presetValues(){this.atmosphere=this.camera=null}updateUniforms(){var a=
this.uniforms;super.updateUniforms();var b=a.fCameraPos.value;b.setFromMatrixPosition(camera.matrixWorld);b.applyMatrix4(this.localWorldInverse);b=b.lengthSq();a.fCameraHeight.value=Math.sqrt(b);a.fCameraHeight2.value=b}addUniforms(a){super.addUniforms(a);a.fg={type:"f",value:0};a.fg2={type:"f",value:0};a.fKrESun={type:"f",value:0};a.fKmESun={type:"f",value:0};a.fKr4PI={type:"f",value:0};a.fKm4PI={type:"f",value:0};a.fScale={type:"f",value:0};a.fBias={type:"f",value:0};a.fExposure={type:"f",value:0};
a.fScaleDepth={type:"f",value:0};a.fOuterRadius={type:"f",value:0};a.fInnerRadius={type:"f",value:0};a.fOuterRadius2={type:"f",value:0};a.fInnerRadius2={type:"f",value:0};a.fCameraHeight={type:"f",value:0};a.fCameraHeight2={type:"f",value:0};a.v3InvWavelength={type:"v3",value:new h.Color};a.fCameraPos={type:"v3",value:new h.Vector3}}getVertexChunks(){var a=super.getVertexChunks();a.push({after:/<common>/,shader:["#if USE_GROUNDSHADER > 0 && NUM_STARS > 0","  uniform vec3 lightPos[NUM_STARS];","  uniform float lightSize[NUM_STARS];",
"  uniform vec3 fCameraPos;       // The Camera Position","  uniform vec3 v3InvWavelength;   // 1 / pow(abs(wavelength), 4) for the red, green, and blue channels","  uniform float fCameraHeight;    // The cameras current height","  uniform float fCameraHeight2;   // fCameraHeight^2","  uniform float fOuterRadius;     // The outer (atmosphere) radius","  uniform float fOuterRadius2;    // fOuterRadius^2","  uniform float fInnerRadius;     // The inner (planetary) radius","  uniform float fInnerRadius2;    // fInnerRadius^2",
"  uniform float fKrESun;          // Kr * ESun","  uniform float fKmESun;          // Km * ESun","  uniform float fKr4PI;           // Kr * 4 * PI","  uniform float fKm4PI;           // Km * 4 * PI","  uniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)","  uniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmospheres average density is found)","  uniform float fBias;            // GroundShader Bias","  varying vec3 v3RayleighColor;","  varying vec3 v3MieColor;",
"  float scale(float fCos)","  {","  \tfloat x = 1.0 - fCos;","  \treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));","  }","#endif"]});a.push({after:/<begin_vertex>/,shader:["#if USE_GROUNDSHADER > 0 && NUM_STARS > 0","  v3RayleighColor *= 0.0;","  v3MieColor *= 0.0;","  float fInvScaleDepth = (1.0 / fScaleDepth);","  float fScaleOverScaleDepth = fScale / fScaleDepth;","  // Do all the calculation in local space, since this yields best precision","  vec3 cameraLocal = fCameraPos; // vec3(modelMatrixInverse * vec4(cameraPosition, 1.0));",
"  // Get the ray from the camera to the vertex and its length","  // which is the far point of the ray passing through the atmosphere","  vec3 v3Ray = (vertexPos - cameraLocal);","  float fFar = length(v3Ray);","  v3Ray /= fFar;","  // Calculate the closest intersection of the ray with the outer atmosphere","  // Which is the near point of the ray passing through the atmosphere","  float B = 2.0 * dot(cameraLocal, v3Ray);","  float C = fCameraHeight2 - fOuterRadius2;","  float fDet = max(0.0, B*B - 4.0 * C);",
"  float fNear = 0.5 * (-B - sqrt(fDet));","  float fDepth = exp((fInnerRadius - fOuterRadius) * fScaleOverScaleDepth);","  float fCameraAngle = dot(-v3Ray, vertexPos) / length(vertexPos);","  float fCameraScale = scale(fCameraAngle);","  float fCameraOffset = fDepth*fCameraScale;",e.StartStaticForLoop("n","NUM_STARS"),"    // Do all the calculation in local space, since this yields best precision","    vec3 lightLocal = lightPos[n]; // vec3(modelMatrixInverse * vec4(starPos[n], 1.0));","    // Calculate the ray's starting vertexPos, then calculate its scattering offset",
"    vec3 v3Start = cameraLocal + v3Ray * fNear;","    fFar -= fNear;","    float fLightAngle = dot(lightLocal, vertexPos) / length(vertexPos);","    float fLightScale = scale(fLightAngle);","    float fTemp = (fLightScale + fCameraScale);","    // Initialize the scattering loop variables","    float fSampleLength = fFar / float(NUM_SAMPLES);","    float fScaledLength = fSampleLength * fScale;","    vec3 v3SampleRay = v3Ray * fSampleLength;","    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;",
"    // Now loop through the sample rays","    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);","    vec3 v3Attenuate;","    for(int i=0; i<NUM_SAMPLES; i++)","    {","        float fHeight = length(v3SamplePoint);","        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));","        float fScatter = fDepth*fTemp - fCameraOffset;","        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));","        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);","        v3SamplePoint += v3SampleRay;",
"    }","    v3RayleighColor += v3FrontColor * (v3InvWavelength * fKrESun + fKmESun) / float(NUM_STARS);","    v3MieColor += v3Attenuate / float(NUM_STARS);",e.EndStaticForLoop("n","NUM_STARS"),"#endif"]});return a}getFragmentChunks(){var a=super.getFragmentChunks();a.push({after:/<common>/,shader:"#if USE_GROUNDSHADER > 0 && NUM_STARS > 0,  varying vec3 v3RayleighColor;,  varying vec3 v3MieColor;,  uniform float fExposure;,  uniform float fBias;,#endif".split(",")});a.push({after:/vec3 outgoingLight/,
shader:["#if USE_GROUNDSHADER > 0 && NUM_STARS > 0","  vec3 color = v3RayleighColor + 0.25 * v3MieColor;","  color = vec3(1.0) - exp(-fExposure * color);","  outgoingLight = mix(outgoingLight, color, fBias);","#endif"]});return a}}f.prototype.atmosphere=null;e.GroundShader=f})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){var f=new h.Matrix4;class a extends e.CustomMaterial(h.ShaderMaterial,"ShaderMaterial","basic"){constructor(b){super(b);this.setDefines({NUM_STARS:0,USE_ATMOSPHERE:""});if(b.atmosphere){var c=b.atmosphere,d=this.uniforms;c.G=c.G||-.95;c.Kr=c.Kr||.0025;c.Km=c.Km||.001;c.ESun=c.ESun||20;c.bias=c.bias||.5;c.exposure=c.exposure||2.5;c.scaleDepth=c.scaleDepth||.25;c.scaleHeight=c.scaleHeight||1.025;c.innerRadius=c.innerRadius||r*KM2AU;var g=c.wavelength;d.v3InvWavelength.value.set(1/Math.pow(g.x,
4),1/Math.pow(g.y,4),1/Math.pow(g.z,4));g=c.G;d.fg.value=g;d.fg2.value=g*g;g=c.Kr;var m=c.Km,k=c.ESun;d.fKrESun.value=g*k;d.fKmESun.value=m*k;d.fKr4PI.value=4*g*Math.PI;d.fKm4PI.value=4*m*Math.PI;g=c.scaleDepth;m=c.innerRadius;k=m+c.height;d.fBias.value=c.bias;d.fExposure.value=c.exposure;d.fScale.value=1/(k-m);d.fScaleDepth.value=g;d.fOuterRadius.value=k;d.fInnerRadius.value=m;d.fOuterRadius2.value=k*k;d.fInnerRadius2.value=m*m}this.stars=[];this.addStar(b.stars||[])}addStar(b){Array.isArray(b)||
(b=[b]);for(var c=0;c<b.length;c++)this.stars.push(b[c]),this.uniforms.lightPos.value.push(new h.Vector3),this.uniforms.lightSize.value.push(2*(b[c].radius||0));this.defines.NUM_STARS+=b.length;this.needsUpdate=!0}updateUniforms(){var b=this.uniforms,c=this.stars,d=b.v3LightPos.value,g=b.v3CameraPos.value;g.setFromMatrixPosition(camera.matrixWorld);d.setFromMatrixPosition(light.matrixWorld);this.pbody&&this.pbody.matrixWorld&&(f.copy(this.pbody.matrixWorld).invert(),d.applyMatrix4(f),g.applyMatrix4(f));
d=g.lengthSq();b.fCameraHeight.value=Math.sqrt(d);b.fCameraHeight2.value=d;for(d=0;d<c.length;d+=1)c[d].getWorldPosition(b.lightPos.value[d]),b.lightPos.value[d].applyMatrix4(f)}addUniforms(b){super.addUniforms(b);b.fg={type:"f",value:0};b.fg2={type:"f",value:0};b.fKrESun={type:"f",value:0};b.fKmESun={type:"f",value:0};b.fKr4PI={type:"f",value:0};b.fKm4PI={type:"f",value:0};b.fScale={type:"f",value:0};b.fBias={type:"f",value:0};b.fExposure={type:"f",value:0};b.fScaleDepth={type:"f",value:0};b.fOuterRadius=
{type:"f",value:0};b.fInnerRadius={type:"f",value:0};b.fOuterRadius2={type:"f",value:0};b.fInnerRadius2={type:"f",value:0};b.fCameraHeight={type:"f",value:0};b.fCameraHeight2={type:"f",value:0};b.v3InvWavelength={type:"v3",value:new h.Vector3};b.v3CameraPos={type:"v3",value:new h.Vector3};b.v3LightPos={type:"v3",value:new h.Vector3};b.lightSize={type:"fv1",value:[]};b.lightPos={type:"v3v",value:[]}}getVertexChunks(){var b=super.getVertexChunks();b.push({after:/<common>/,shader:["#if NUM_STARS > 0",
"  uniform vec3 lightPos[NUM_STARS];","  uniform float lightSize[NUM_STARS];","#endif","// These must be passed in local object space","  uniform vec3 v3LightPos;        // The Light Position","  uniform vec3 v3CameraPos;       // The Camera Position","  uniform vec3 v3InvWavelength;   // 1 / pow(abs(wavelength), 4) for the red, green, and blue channels","  uniform float fCameraHeight;    // The cameras current height","  uniform float fCameraHeight2;   // fCameraHeight^2","  uniform float fOuterRadius;     // The outer (atmosphere) radius",
"  uniform float fOuterRadius2;    // fOuterRadius^2","  uniform float fInnerRadius;     // The inner (planetary) radius","  uniform float fInnerRadius2;    // fInnerRadius^2","  uniform float fKrESun;          // Kr * ESun","  uniform float fKmESun;          // Km * ESun","  uniform float fKr4PI;           // Kr * 4 * PI","  uniform float fKm4PI;           // Km * 4 * PI","  uniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)","  uniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmospheres average density is found)",
"  uniform float fBias;            // GroundShader Bias","  varying vec3 v3Direction;","  varying vec3 v3RayleighColor;","  varying vec3 v3MieColor;","  varying float fMiePhase;","  uniform float fg;","  uniform float fg2;","  const int nSamples = 16;","  const float fSamples = float(nSamples); // or 1.125","  float scale(float fCos)","  {","  \tfloat x = 1.0 - fCos;","  \treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));","  }"]});b.push({after:/<begin_vertex>/,shader:["  // vec3 v3CameraPos = cameraPosition; // vec3(1.5, 0.5, 10.0);",
"  float fCameraHeight = length(v3CameraPos);","  float fCameraHeight2 = fCameraHeight * fCameraHeight;","  float fInvScaleDepth = (1.0 / fScaleDepth);","  float fScaleOverScaleDepth = fScale / fScaleDepth;","  // Do all the calculation in local space, since this yields best precision","  vec3 cameraLocal = v3CameraPos; // vec3(modelMatrixInverse * vec4(cameraPosition, 1.0));","  // Get the ray from the camera to the vertex and its length","  // which is the far point of the ray passing through the atmosphere",
"  vec3 v3Pos = position; //","  vec3 v3Ray = position - cameraLocal;","  float fFar = length(v3Ray);","  v3Ray /= fFar;","  // Pass direction to fragment shader","  v3Direction = v3CameraPos - v3Pos;","  // Calculate the closest intersection of the ray with the outer atmosphere","  // Which is the near point of the ray passing through the atmosphere","  float B = 2.0 * dot(v3CameraPos, v3Ray);","  float C = fCameraHeight2 - fOuterRadius2;","  float fDet = max(0.0, B*B - 4.0 * C);","  float fNear = 0.5 * (-B - sqrt(fDet));",
"  // Calculate the ray's starting position, then calculate its scattering offset","  vec3 v3Start = v3CameraPos + v3Ray * fNear;","  fFar -= fNear;","  float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;","  float fStartDepth = exp(-1.0 / fScaleDepth);","  float fStartOffset = fStartDepth*scale(fStartAngle);","  // Initialize the scattering loop variables","  float fSampleLength = fFar / fSamples;","  float fScaledLength = fSampleLength * fScale;","  vec3 v3SampleRay = v3Ray * fSampleLength;",
"  vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;","  // Now loop through the sample rays","  vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);","  for(int i=0; i<nSamples; i++)","  {","    float fHeight = length(v3SamplePoint);","    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));","    float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;",e.StartStaticForLoop("n","NUM_STARS"),"        float fLightAngle = dot(lightPos[n], v3SamplePoint) / fHeight;","        float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));",
"        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));","        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);","        v3SamplePoint += v3SampleRay;",e.EndStaticForLoop("n","NUM_STARS"),"  }","  v3RayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);","  v3MieColor = v3FrontColor * fKmESun;;","vec3 lightPos = lightPos[0];","lightPos *= 0.95;","float fCos = dot(lightPos, v3Direction) / length(v3Direction);","fMiePhase = 1.5 * ((1.0 - fg2) / (2.0 + fg2)) * (1.0 + fCos*fCos) / pow(1.0 + fg2 - 2.0*fg*fCos, 1.5);"]});
return b}getFragmentChunks(){var b=super.getFragmentChunks();b.unshift({after:/<common>/,shader:"#if NUM_STARS > 0,  uniform vec3 lightPos[NUM_STARS];,  uniform float lightSize[NUM_STARS];,#endif,#ifdef USE_ATMOSPHERE,  uniform float fg;,  uniform float fg2;,  uniform vec3 v3LightPos;,  varying vec3 v3RayleighColor;,  varying vec3 v3MieColor;,  varying vec3 v3Direction;,  varying float fMiePhase;,  uniform float fExposure;,  uniform float fBias;,#endif".split(",")});b.push({after:/vec3 outgoingLight/,
shader:["outgoingLight = v3RayleighColor + fMiePhase * v3MieColor;","outgoingLight = vec3(1.0, 1.0, 1.0) - exp(-fExposure * outgoingLight);","float lum = 0.2126*outgoingLight.r + 0.7152*outgoingLight.g + 0.0722*outgoingLight.b;","diffuseColor.a = clamp(lum, 0.0, 1.0);"]});return b}}a.prototype.stars=null;a.prototype.atmosphere=null;e.SkyShader=a})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){class f extends e.CustomMeshPhysicalMaterial{constructor(a){super(a);this.setDefines({NUM_ECLIPSERS:0});a.planetRadius&&(this.uniforms.planetRadius.value=a.planetRadius);a.eclipsers&&(a=a.eclipsers,Array.isArray(a)||(a=[a]),this.defines.NUM_ECLIPSERS=a.length)}addUniforms(a){super.addUniforms(a);a.planetRadius={type:"f",value:0}}getVertexChunks(){var a=super.getVertexChunks();a.unshift({after:/<common>/,shader:["  // The planetary radius","  uniform float planetRadius;","  // Pass world space to fragments",
"  varying vec3 vertexPos;","  varying vec3 originPos;"]});a.unshift({after:/<begin_vertex>/,shader:["  // convert from local space to camera space","  vertexPos = vec3(modelViewMatrix * vec4(position, 1.0));","  originPos = vec3(modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0));"]});return a}getFragmentChunks(){var a=super.getFragmentChunks();a.unshift({after:/<common>/,shader:["  // The planetary radius","  uniform float planetRadius;","  // Pass world space to fragments","  varying vec3 vertexPos;",
"  varying vec3 originPos;","  // Return distance between line AB and point P","  // Positive if intersection is behind the object.","  // Negative if intersection is in front of the object.","  float lineDistToPoint(vec3 A, vec3 B, vec3 P) {","    // represent the line segment AB as a vector.","    vec3 AB = B - A;","    // I am a bit worried about branch performance?","    // http://stackoverflow.com/a/4176288/1550314","    // if (length(B - P) > length(AB)) return 9e32;","    // calculate front step value to determine on which",
"    // side the shadow lies (only shade behind object).","    float front = step(0.0, length(B - P) - length(AB));","    // determine the direction of B relative to A.","    vec3 AB_dir = normalize( AB );","    // compute the distance between A and Q using the dot","    // product trick. The first argument is a unit length","    // vector. The second argument is a point *relative to","    // that vector*.","    float AQ_len = dot( AB_dir, P - A );","    // Now that we know the length of AQ, we can compute Q.",
"    // To do this, think of the following equation as start","    // at A; move along the direction AB_dir by AQ_len units;","    // that position is Q.","    vec3 Q = A + AQ_len * AB_dir;","    // return the length of PQ (negative if front).","    return length( Q - P ) * (-front * 2.0 + 1.0);","  }"]});a.unshift({after:/<aomap_fragment>/,shader:["  float shaded = 0.0;","#if NUM_POINT_LIGHTS > 0 && NUM_ECLIPSERS > 0",e.StartStaticForLoop("i","NUM_POINT_LIGHTS"),"    // Get camera position in eye/view coordinates",
"    vec3 light = pointLights[ i ].position;","    // Calculate distance from touch point from planet origin","    float dist = lineDistToPoint(vertexPos, light, originPos);","    shaded += 1.0 - clamp(pow(dist / planetRadius, 64.0), 0.0, 1.0);",e.EndStaticForLoop("i","NUM_POINT_LIGHTS"),"#endif","#if NUM_POINT_LIGHTS > 1","  shaded /= float(NUM_POINT_LIGHTS);","#endif"]});a.unshift({after:/vec3 outgoingLight/,shader:["outgoingLight *= 1.0 - shaded;"]});return a}}f.prototype.planetRadius=null;f.prototype.eclipsers=
null;e.RingShader=f})(THREE,THRAPP);

/* crc: 7BA83ADF744B60584E5AE7E25804B7E3 */
