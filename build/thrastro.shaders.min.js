/* autogenerated by webmerge (compile context) */
;
/*
Three.js App Framework (https://github.com/mgreter/three.app)
- Copyright (c) 2017-2022 Marcel Greter (http://github.com/mgreter)
*/;
'use strict';window.THRAPP||(window.THRAPP={});
(function(h,e){function g(k,n,t,u){t=t.shader||"";u=u?1:0;Array.isArray(t)&&(t=t.join("\n"));return k.splice(n,u,t)}function c(k,n){if(k&&k.length)for(var t=0;t<k.length;t++){for(var u=!1,l=k[t],p=0;p<n.length;p++)l.after&&l.after.test(n[p])?(g(n,p+1,l,!1),p+=2,u=!0):l.before&&l.before.test(n[p])?(g(n,p,l,!1),p+=2,u=!0):l.replace&&l.replace.test(n[p])&&(g(n,p,l,!0),p+=1,u=!0);if(!u)throw Error("Shader Chunk not found");}}function a(k,n){k=h.ShaderChunk[n];if(void 0===k)throw Error("Can not resolve #include <"+
n+">");return k.replace(m,a)}function b(k,n,t){class u extends k{constructor(l){l=l||{};super(l);this.type=n;var p=h.ShaderLib[t];this.defines=this.defines||[];var v=p.vertexShader.split(/\n+/);c(this.getVertexChunks(),v);var w=p.fragmentShader.split(/\n+/);c(this.getFragmentChunks(),w);this.vertexShader=this.getVertexShader(v.join("\n"));this.fragmentShader=this.getFragmentShader(w.join("\n"));this.vertexShader=this.vertexShader.replace(m,a);this.fragmentShader=this.fragmentShader.replace(m,a);v=
this.vertexShader.split(/\n+/);c(this.getVertexSubChunks(),v);w=this.fragmentShader.split(/\n+/);c(this.getFragmentSubChunks(),w);this.vertexShader=v.join("\n");this.fragmentShader=w.join("\n");this.uniforms=h.UniformsUtils.merge([l.uniforms,p.uniforms]);this.addUniforms(this.uniforms);this.setValues(l)}setDefines(l){for(var p in l)this.defines[p]=l[p]}getFragmentShader(l){return l}getVertexShader(l){return l}getVertexChunks(){return[]}getFragmentChunks(){return[]}getVertexSubChunks(){return[]}getFragmentSubChunks(){return[]}addUniforms(l){}updateUniforms(){}}
return u}class d extends h.RawShaderMaterial{constructor(k){k=k||{};k.glslVersion="300 es";super(k)}vertexShaderPrefix(k){return""}}class f extends h.Mesh{constructor(k,n){super(k,n);n.pbody=this}}const m=/^[ \t]*#include +<([\w\d./]+)>/gm;h.ShaderLib.none={uniforms:{},vertexShader:"",fragmentShader:""};e.CustomMaterial=b;class q extends b(h.ShaderMaterial,"CustomShaderMaterial","basic"){constructor(k){super(k)}}class x extends b(h.MeshBasicMaterial,"CustomMeshBasicMaterial","basic"){constructor(k){super(k)}}
class y extends b(h.MeshLambertMaterial,"CustomMeshLambertMaterial","lambert"){constructor(k){super(k)}}class z extends b(h.MeshPhongMaterial,"CustomMeshPhongMaterial","phong"){constructor(k){super(k)}}class A extends b(h.MeshPhysicalMaterial,"CustomMeshPhysicalMaterial","physical"){constructor(k){super(k)}}e.Mesh=f;e.CustomRawShader=d;e.CustomShaderMaterial=q;e.CustomMeshBasicMaterial=x;e.CustomMeshLambertMaterial=y;e.CustomMeshPhongMaterial=z;e.CustomMeshPhysicalMaterial=A;e.StartStaticForLoop=
function(k,n){return[`#if ${n} > 0`,`#if ${n} > 1`,`  for ( int ${k} = 0; ${k} < ${n}; ++ ${k} ) {`,"#else",`  { int ${k} = 0;`,"#endif\n"].join("\n")};e.EndStaticForLoop=function(k,n){return"  }\n#endif\n"}})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){new h.Matrix4;class g extends e.CustomRawShader{constructor(c){c=c||{};let a=c.defines||{};super(c);this.isRawShaderMaterial=!0;this.defines.USE_LOGDEPTHBUF=a.USE_LOGDEPTHBUF;this.defines.USE_LOGDEPTHBUF_EXT=a.USE_LOGDEPTHBUF_EXT;this.uniforms.time={type:"f",value:c.time||0};this.uniforms.fov={type:"f",value:c.fov||4};this.uniforms.scale={type:"f",value:c.scale||0};this.uniforms.minMag={type:"f",value:c.minMag||0};this.uniforms.maxMag={type:"f",value:c.maxMag||0};this.uniforms.opacity=
{type:"f",value:c.opacity||0};this.uniforms.magFact={type:"f",value:c.magFact||0};this.uniforms.magScale={type:"f",value:c.magScale||0};this.uniforms.sizeScale={type:"f",value:c.sizeScale||0};this.vertexShader="\n\n\n\n        #define varying out\n\n        #define attribute in\n\n        out highp vec4 pc_fragColor;\n\n        #define gl_FragColor pc_fragColor\n\n        #define gl_FragDepthEXT gl_FragDepth\n\n\n\n        precision highp float;\n\n        precision highp int;\n\n        #define HIGH_PRECISION\n\n        #define SHADER_NAME CustomLineMaterial\n\n        #define GAMMA_FACTOR 2\n\n        uniform mat4 viewMatrix;\n\n        uniform vec3 cameraPosition;\n\n        uniform bool isOrthographic;\n\n        uniform mat4 modelMatrix;\n\n        uniform mat4 modelViewMatrix;\n\n        uniform mat4 projectionMatrix;\n\n        uniform mat3 normalMatrix;\n\n\n\n        // ***************************************************************\n\n        // ***************************************************************\n\n        #include <common>\n\n        #include <logdepthbuf_pars_vertex>\n\n\n\n        uniform float time;\n\n        uniform float scale;\n\n        uniform float min;\n\n        \n\n        uniform float fov;\n\n        uniform float minMag;\n\n        uniform float maxMag;\n\n        \n\n        uniform float norm;\n\n        uniform float fact;\n\n        uniform float opacity;\n\n        \n\n        uniform float magFact;\n\n        uniform float magScale;\n\n        \n\n        uniform float sizeScale;\n\n        \n\n        attribute vec4 position;\n\n        attribute vec4 attributes;\n\n        \n\n        varying vec4 col;\n\n        varying float camdist;\n\n        \n\n        // create constant ensure best performance\n\n        // const float kLogBase10 = 1.0 / log( 10.0 );\n\n        const float kLogBase10 = 0.43429448190325176;\n\n        \n\n        float log10( in float n )\n\n        {\n\n            // calculate log2 to log10\n\n            return log( n ) * kLogBase10;\n\n        }\n\n        \n\n        // RGB <0,1> <- BV <-0.4,+2.0> [-]\n\n        vec4 bv2rgb(float bv, float mag)\n\n        {\n\n            float t;\n\n            float r = 0.0;\n\n            float g = 0.0;\n\n            float b = 0.0;\n\n            if (bv<-0.4) bv=-0.4;\n\n            if (bv> 1.95) bv= 1.95;\n\n            // http://www.vendian.org/mncharity/dir3/starcolor/details.html\n\n                 if ((bv>=-0.40)&&(bv<0.00)) { t=(bv+0.40)/(0.00+0.40); r=0.61+(0.11*t)+(0.1*t*t); }\n\n            else if ((bv>= 0.00)&&(bv<0.40)) { t=(bv-0.00)/(0.40-0.00); r=0.83+(0.17*t)          ; }\n\n            else if ((bv>= 0.40)&&(bv<2.10)) { t=(bv-0.40)/(2.10-0.40); r=1.00                   ; }\n\n                 if ((bv>=-0.40)&&(bv<0.00)) { t=(bv+0.40)/(0.00+0.40); g=0.70+(0.07*t)+(0.1*t*t); }\n\n            else if ((bv>= 0.00)&&(bv<0.40)) { t=(bv-0.00)/(0.40-0.00); g=0.87+(0.11*t)          ; }\n\n            else if ((bv>= 0.40)&&(bv<1.60)) { t=(bv-0.40)/(1.60-0.40); g=0.98-(0.16*t)          ; }\n\n            else if ((bv>= 1.60)&&(bv<2.00)) { t=(bv-1.60)/(2.00-1.60); g=0.82         -(0.5*t*t); }\n\n                 if ((bv>=-0.40)&&(bv<0.40)) { t=(bv+0.40)/(0.40+0.40); b=1.00                   ; }\n\n            else if ((bv>= 0.40)&&(bv<1.50)) { t=(bv-0.40)/(1.50-0.40); b=1.00-(0.47*t)+(0.1*t*t); }\n\n            else if ((bv>= 1.50)&&(bv<1.94)) { t=(bv-1.50)/(1.94-1.50); b=0.63         -(0.6*t*t); }\n\n            return vec4(r, g, b, mag);\n\n        }\n\n        \n\n        void main()\n\n        {\n\n        \n\n            // gl_PointSize = 200.0;\n\n            // mag: -27 to 21 (abs: -17 to 20)\n\n            // mag = (23.0 - position.a) / 50.0;\n\n        \n\n            float mag = position.a;\n\n        \n\n        \n\n        \n\n        /*\n\n            if (mag < norm) {\n\n                mag = 1.0;\n\n                gl_PointSize = pow(abs(1.0 + norm - mag), fact);\n\n            } else if (mag > min) {\n\n                mag = 0.0;\n\n                gl_PointSize = 0.0;\n\n                // discard;\n\n            } else {\n\n                mag = (min - mag) / (min - norm);\n\n                gl_PointSize = pow(abs(mag), fact);\n\n                mag = pow(abs(mag), magScale);\n\n            }\n\n        */\n\n        \n\n        // I am distance away from zero point\n\n        // Camera may be somewhere else\n\n        // get the real distance\n\n        \n\n            col = bv2rgb(attributes.a, 1.0); // mag\n\n            // gl_PointSize *= sizeScale * 2.0;\n\n        \n\n            float pm_ra = attributes.x;\n\n            float pm_dec = attributes.y;\n\n        \n\n            float ra = position.x;\n\n            float dec = position.y;\n\n            float radius = position.z;\n\n        \n\n            // 206264806.2471\n\n            // time is in julian years\n\n            // movement is rads per year\n\n            // hyg pmrarad/decrad (25,26)\n\n            ra += pm_ra * time / 206300000.0;\n\n            dec += pm_dec * time / 206300000.0;\n\n        \n\n            float x = cos(dec) * cos(ra) * radius;\n\n            float y = cos(dec) * sin(ra) * radius;\n\n            float z = sin(dec) * radius;\n\n        \n\n            vec4 pos = vec4(x, y, z, 1.0);\n\n        \n\n            // get distance between camera and star\n\n        \n\n            float factr = 206264.80748432202;\n\n        \n\n            // we probably want to calculate distance from stars to\n\n            // camera in model space, even if the final results are\n\n            // in scaled world coordinates. Otherwise the distance\n\n            // will be in world coordinates and the falloff could\n\n            // be way to fast. Using an uniform is the fastest way!\n\n            // Otherwise we would need a full inverseModelMatrix.\n\n            float camStarDist = distance(cameraPosition / factr, pos.xyz);\n\n        \n\n            // the camera distance can be usefull to enhance view\n\n            // when far away from the center or close to it.\n\n            // keep it in world space or also use factor?\n\n            float camZoomDist = length(cameraPosition);\n\n        \n\n            camdist = camStarDist;\n\n        \n\n            // calculate apparent magnitude (physically accurate)\n\n            float vmag = mag - 5.0 + 5.0 * log10(camStarDist);\n\n        \n\n            // calculate point size from visual magnitude\n\n            gl_PointSize = magFact * exp(- magScale * vmag);\n\n            // apply global point size scale\n\n            gl_PointSize *= sizeScale;\n\n            // make sure the point does not get too big\n\n            gl_PointSize = clamp(gl_PointSize, 0.0, 75.0);\n\n            // zoom field of view\n\n            gl_PointSize *= fov;\n\n        \n\n            // attenuate sizes once we are far away\n\n            gl_PointSize += clamp(camZoomDist / 50000000.0, 0.2, 3.5);\n\n        \n\n            // dim out stars that are very close to the camera\n\n            // mostly needed for our sun to outshine the screen\n\n            col.a *= clamp(camStarDist * 1.0e5, 0.0, 1.0);\n\n        \n\n            // apply min/max magnitude filtering\n\n            col.a -= smoothstep(minMag, maxMag, vmag);\n\n        \n\n            // reduce flickering of very small and faintd stars\n\n            col.a *= smoothstep(0.0, 3.0, pow(gl_PointSize, 0.5));\n\n        \n\n            // if (gl_PointSize < 3.0) col.a = 0.0;a\n\n            // gl_PointSize = max(1.0, gl_PointSize);\n\n        \n\n            // apply global opacity\n\n            col.a *= opacity;\n\n        \n\n            // Only dimm stars very close to the sun\n\n            col.a *= 1.0 - smoothstep(1.0e6, 1.0e9, length(cameraPosition));\n\n                //* (1.0 - smoothstep(1.0e4, 1.0e6, radius));\n\n        \n\n        \n\n            // calculate screen position (the regular way)\n\n            gl_Position = projectionMatrix * modelViewMatrix * pos;\n\n        \n\n            // THREE.ShaderChunk[ 'logdepthbuf_vertex'\n\n            #include <logdepthbuf_vertex>\n\n        \n\n        }\n\n        \n\n        ";
this.fragmentShader="\n\n        \n\n        // ***************************************************************\n\n        // ***************************************************************\n\n        #define varying in\n\n        out highp vec4 pc_fragColor;\n\n        #define gl_FragColor pc_fragColor\n\n        #define gl_FragDepthEXT gl_FragDepth\n\n\n\n        // ***************************************************************\n\n        // orbit.frag\n\n        // ***************************************************************\n\n        precision highp float;\n\n        precision highp int;\n\n        #include <common>\n\n        #include <logdepthbuf_pars_fragment>\n\n        // ***************************************************************\n\n        // ***************************************************************\n\n\n\n        \n\nvarying vec4 col;\n\nvarying float camdist;\n\n\n\n// static background color (transparent)\n\nvec4 bg_col = vec4(0.0, 0.0, 0.0, 0.0);\n\n\n\n// ***************************************************************\n\n// ***************************************************************\n\n\n\nmat2 rotate = mat2(\n\n\t0.707107, 0.707107,\n\n\t-0.707107, 0.707107\n\n);\n\n\n\nvoid main()\n\n{\n\n\n\n\t// get uv coordinates (from -0.5 to +0.5)\n\n\tvec2 uv = gl_PointCoord - vec2(0.5, 0.5);\n\n\n\n\t// calculate distance to center\n\n\tfloat dist = 1.0 - length(uv) * 2.0;\n\n\n\n    dist = smoothstep(0.0, 1.0, pow(dist, 6.0));\n\n\n\n    float nearf = clamp(camdist * 0.5, 0.0, 1.0);\n\n    float atten = 0.7; float atten2 = 3.0;\n\n    float ax = exp(- pow(abs(uv.x * atten2), atten) ) * (1.0 - pow(abs(uv.y * atten2), atten));\n\n    float bx = exp(- pow(abs(uv.y * atten2), atten) ) * (1.0 - pow(abs(uv.x * atten2), atten));\n\n\t// ax = smoothstep(0.0, 1.0, pow(ax, 1.0));\n\n\t// bx = smoothstep(0.0, 1.0, pow(bx, 1.0));\n\n    // ax = 1.0 - (1.0 - ax) * (1.0 - pow(dist, 20.9));\n\n    //ax *= pow(dist, 0.05); // attenuate spikes\n\n    //bx *= pow(dist, 0.07); // attenuate spikes\n\n    // bx = 1.0 - (1.0 - bx) * (1.0 - pow(dist, 20.9));\n\n    // ax *= smoothstep(0.0, 1.0, pow(dist, 0.05));\n\n    // bx *= smoothstep(0.0, 1.0, pow(dist, 0.05));\n\n\n\n    dist = max(dist, pow(ax, 1.125) * nearf);\n\n\tdist = max(dist, pow(bx, 1.125) * nearf);\n\n\n\n    // dist = pow(bx, 1.0);\n\n\n\n    \n\n\t// if (dist > 0.9) dist = 1.0;\n\n\t// mix up the final circle color\n\n\t// gl_FragColor = mix(col, bg_col, t);\n\n\tgl_FragColor = col * pow(dist, 2.0);\n\n\n\n\n\n\t// float twinke = uv.x * uv.y * 2.0;\n\n\t// gl_FragColor.a *= 1.0 - clamp(twinke, 0.0, 1.0);\n\n\n\n\t// THREE.ShaderChunk[ 'logdepthbuf_fragment' ]\n\n\t#include <logdepthbuf_fragment>\n\n\n\n}\n\n\n\n        "}addUniforms(c){super.addUniforms(c)}updateUniforms(){super.updateUniforms()}}
g.prototype.time=null;g.prototype.fov=null;g.prototype.scale=null;g.prototype.minMag=null;g.prototype.maxMag=null;g.prototype.opacity=null;g.prototype.magFact=null;g.prototype.magScale=null;g.prototype.sizeScale=null;e.FirmamentShader=g})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){new h.Matrix4;class g extends e.CustomRawShader{constructor(c){super(c);this.defines.USE_LOGDEPTHBUF=1;this.defines.USE_LOGDEPTHBUF_EXT=1;this.isRawShaderMaterial=!0;this.uniforms.time={type:"f",value:c.scale||0};this.uniforms.scale={type:"f",value:c.scale||1};this.uniforms.lucency={type:"f",value:c.lucency||.75};this.uniforms.attenuate={type:"f",value:c.attenuate||0};this.uniforms.trailStart={type:"f",value:c.trailStart||0};this.uniforms.trailLength={type:"f",value:c.trailLength||
1};null!=this.defines.LAPLACE_PLANE&&(this.uniforms.laplaceEpoch={type:"f",value:c.laplaceEpoch||0});this.vertexShader="\n\n\n\n        #define varying out\n\n        #define attribute in\n\n        out highp vec4 pc_fragColor;\n\n        #define gl_FragColor pc_fragColor\n\n        #define gl_FragDepthEXT gl_FragDepth\n\n\n\n        precision highp float;\n\n        precision highp int;\n\n        #define HIGH_PRECISION\n\n        #define SHADER_NAME CustomLineMaterial\n\n        #define GAMMA_FACTOR 2\n\n        uniform mat4 viewMatrix;\n\n        uniform vec3 cameraPosition;\n\n        uniform bool isOrthographic;\n\n        uniform mat4 modelMatrix;\n\n        uniform mat4 modelViewMatrix;\n\n        uniform mat4 projectionMatrix;\n\n        uniform mat3 normalMatrix;\n\n\n\n        // ***************************************************************\n\n        // orbit.vert\n\n        // ***************************************************************\n\n        #include <common>\n\n        #include <logdepthbuf_pars_vertex>\n\n\n\n        // Gravitational Constant\n\n        #ifdef USE_GLOBAL_GM\n\n        uniform float GM;\n\n        #else\n\n        attribute float GM;\n\n        #endif\n\n        \n\n        // Gravitational Constant\n\n        #ifdef USE_GLOBAL_EPOCH\n\n        uniform float epoch;\n\n        #else\n\n        attribute float epoch;\n\n        #endif\n\n\n\n        // time in julian days\n\n        // uniform float time;\n\n        uniform float time;\n\n        \n\n        //uniform float itime;\n\n        //uniform float ftime;\n\n        \n\n        // global lucency value\n\n        uniform float lucency;\n\n        uniform float attenuate;\n\n        \n\n        // scale the positions\n\n        uniform float scale;\n\n        uniform float trailLength;\n\n        uniform float trailStart;\n\n        \n\n        // from interleaved buffer\n\n        //attribute vec2 epoch;\n\n        attribute vec3 color;\n\n        attribute vec3 l_orbitals;\n\n        attribute vec3 h_orbitals;\n\n        attribute float rotate;\n\n\n\n        // dynamic laplace plane\n\n        #ifdef LAPLACE_PLANE\n\n        attribute vec4 laplace;\n\n        uniform float laplaceEpoch;\n\n        #endif\n\n\n\n        attribute vec2 precession;\n\n        \n\n        // position around ellipse\n\n        attribute float position;\n\n        attribute float position3;\n\n\n\n        // pass to fragment shader\n\n        varying vec4 fragColor;\n\n\n\n// ***************************************************************\n\n// calculate position from VSOP elements (alkhqp)\n\n// this function is adapted from VSOP2013.f\n\n// ***************************************************************\n\n#ifdef ELEMENTS_VSOP\n\n\n\n\tvec3 orb2cart(float arc, float a, float l, float k, float h, float q, float p)\n\n\t{\n\n\n\n\t\tfloat fi = sqrt(1.0 - k*k - h*h);\n\n\t\tfloat ki = sqrt(1.0 - q*q - p*p);\n\n\t\tfloat u = 1.0 / (1.0 + fi);\n\n\t\tvec2 z = vec2(k, h);\n\n\n\n\t\tfloat ex = length(z);\n\n\t\tfloat ex2 = ex * ex;\n\n\t\tfloat ex3 = ex2 * ex;\n\n\n\n    float n = sqrt(GM / a / a / a);\n\n    // orbit._n = sqrt(orbit._G / pow(orbit._a, 3.0));\n\n\t\tfloat gl = mod(l + (time - epoch) * n + arc, PI2);\n\n\t\tfloat gm = gl - atan(h, k);\n\n\t\tfloat e = gl + (ex - 0.125 * ex3) * sin(gm)\n\n\t\t\t\t+ 0.5 * ex2 * sin(2.0 * gm)\n\n\t\t\t\t+ 0.375 * ex3 * sin(3.0 * gm);\n\n\n\n\t\tvec2 z3;\n\n\t\tvec2 zteta;\n\n\t\tfloat rsa = 0.0;\n\n\n\n\t\tfor (int count = 0; count < 10; count ++) {\n\n\t\t\tzteta.x = cos(e);\n\n\t\t\tzteta.y = sin(e);\n\n\t\t\tz3.x = k*zteta.x+h*zteta.y;\n\n\t\t\tz3.y = k*zteta.y-h*zteta.x;\n\n\t\t\tfloat dl = gl - e + z3.y;\n\n\t\t\trsa = 1.0 - z3.x;\n\n\t\t\t// not sure if the branching is more expensive\n\n\t\t\t// what we gain from not running the whole loop\n\n\t\t\tif (abs(dl) < 1e-15) break;\n\n\t\t\te += dl / rsa;\n\n\t\t}\n\n\n\n\t\t// optimized for performance\n\n\t\tfloat ztox = (zteta.x - z.x + z.y * u * z3.y) / rsa;\n\n\t\tfloat ztoy = (zteta.y - z.y - z.x * u * z3.y) / rsa;\n\n\n\n\t\tfloat r = a * rsa;\n\n\t\tfloat m = p * ztox - q * ztoy;\n\n\n\n\t\treturn vec3(\n\n\t\t\tr * (ztox - 2.0 * p * m),\n\n\t\t\tr * (ztoy + 2.0 * q * m),\n\n\t\t\t-2.0 * r * ki * m\n\n\t\t);\n\n\n\n\t}\n\n\n\n// ***************************************************************\n\n// calculate position from orbital elements\n\n// ***************************************************************\n\n#else\n\n\n\n\tvec3 orb2cart(float arc, float e, float a, float i, float O, float w, float M0)\n\n\t{\n\n\n\n\t\t// ToDo: time should be in double precision\n\n\t\t// needs two uniforms: 32ipart and 32fpart\n\n\n\n\t\t// Calculate mean anomaly M(t)\n\n\t\t// with u for sun as central body\n\n\t\tfloat dt = time - epoch; // + 0.5 / 365.25;\n\n\n\n    // dynamic laplace plane\n\n\t\t#ifdef LAPLACE_PLANE\n\n\t\t\t// adjust for laplace precession\n\n\t\t\t//float rot_O = (time - laplaceEpoch) * laplace.z;\n\n\t\t\t// rot_O -= (laplaceEpoch * laplace.z);\n\n\t\t\t//float rot_W = (time - laplaceEpoch) * laplace.w;\n\n\t\t\t// rot_W -= (laplaceEpoch * laplace.w);\n\n\t\t\t// rotate into laplace plane\n\n\t\t\t//O -= laplace.x;\n\n      //w -= laplace.y;\n\n      //i -= laplace.z;\n\n\n\n\t\t\t//w += rot_W;\n\n\t\t#endif\n\n\n\n    O += dt * precession.x;\n\n    w += dt * precession.y;\n\n\n\n\t\t// calculate orbital period factor\n\n\t\tfloat n = sqrt(pow(a, 3.0) / GM);\n\n\n\n\t\t// M = CYCLE(orbit._n * (dt - orbit._T - epoch))\n\n\t\tfloat M = M0 + dt / n;\n\n    // M += 0.1758;\n\n\n\n\n\n\t\t// solve the kepler equation\n\n\t\t// M(t) = E(t) - s * sin(E)\n\n\t\t// for the eccentric anomaly E(t)\n\n\t\t// this must be done iteratively\n\n\t\tfloat E = mod(M, PI2);\n\n\n\n\t\t// M = orbit._n * (dt - orbit._T - epoch);\n\n\n\n\t\t// we can either add arc first, to adjust\n\n\t\t// the offset with the actual speed the\n\n\t\t// object would travel. But this gives\n\n\t\t// a bad distribution of points on the\n\n\t\t// ellipsis. Comet icarus would have a\n\n\t\t// very rough bump on the periapsis.\n\n\n\n\t\t// Newton-Raphson method to solve\n\n\t\t// f(E) = M - E + e * sin(E) = 0\n\n\t\tfor (int it = 0; it < 20; ++it) {\n\n\t\t\tfloat f = M - E + e * sin(E);\n\n\t\t\tfloat dfdE = e * cos(E) - 1.0;\n\n\t\t\tfloat dE = f / dfdE;\n\n\t\t\tE -= dE; // next iteration\n\n\t\t}\n\n\n\n\t\t// add offset now to distribute\n\n\t\t// the vertices accordingly\n\n\t\tE = mod(E, PI2) + arc;\n\n\t\t// E = 4.769749851054432 + arc;\n\n\n\n\t\t// Obtain the true anomaly vector(t)\n\n\t\tfloat v1 = sqrt(1.0 + e) * sin(E/2.0);\n\n\t\tfloat v2 = sqrt(1.0 - e) * cos(E/2.0);\n\n\t\tfloat m = 2.0 * atan( v1, v2 );\n\n\n\n\t\t// Distance to true anomaly position\n\n\t\tfloat r = a * (1.0 - e * cos(E));\n\n\n\n\t\t// Factors for projection\n\n\t\tfloat px = r * cos(m);\n\n\t\tfloat py = r * sin(m);\n\n\n\n\t\t// Precalculations\n\n\t\tfloat cosW = cos(w);\n\n\t\tfloat cosO = cos(O);\n\n\t\tfloat cosI = cos(i);\n\n\t\tfloat sinW = sin(w);\n\n\t\tfloat sinO = sin(O);\n\n\t\tfloat sinI = sin(i);\n\n\n\n\t\tfloat sinWcosO = sinW*cosO;\n\n\t\tfloat sinWsinO = sinW*sinO;\n\n\t\tfloat cosWcosO = cosW*cosO;\n\n\t\tfloat cosWsinO = cosW*sinO;\n\n\n\n\t\tfloat FxX = (cosW*cosO - sinW*sinO*cosI);\n\n\t\tfloat FyX = (cosW*sinO + sinW*cosO*cosI);\n\n\t\tfloat FxY = (cosW*sinO*cosI + sinW*cosO);\n\n\t\tfloat FyY = (cosW*cosO*cosI - sinW*sinO);\n\n\t\tfloat FzX = (sinW*sinI);\n\n\t\tfloat FzY = (cosW*sinI);\n\n\n\n\t\t// calculate cartesian coordinates\n\n\t\tfloat x = + px * FxX - py * FxY;\n\n\t\tfloat y = + px * FyX + py * FyY;\n\n\t\tfloat z = + px * FzX + py * FzY;\n\n\n\n\t\tvec3 coord = vec3(x, y, z);\n\n\n\n\t\t// dynamic laplace plane\n\n\t\t#ifdef LAPLACE_PLANE\n\n\n\n\t\t\t// laplace precession\n\n\t\t\tfloat node = (laplace.x + PI * 0.5);\n\n\t\t\tfloat incl = (PI * 0.5 - laplace.y);\n\n\n\n\t\t\tmat3 rotX = mat3(\n\n\t\t\t\t1.0, 0.0, 0.0,\n\n\t\t\t\t0.0, cos(incl), sin(incl),\n\n\t\t\t\t0.0, - sin(incl), cos(incl)\n\n\t\t\t);\n\n//\n\n//\t\t\tmat3 rotY = mat3(\n\n//\t\t\t\tcos(ay), 0.0, sin(ay),\n\n//\t\t\t\t0.0, 1.0, 0.0,\n\n//\t\t\t\t- sin(ay), 0.0, cos(ay)\n\n//\t\t\t);\n\n//\n\n      mat3 rotZ = mat3(\n\n\t\t\t\tcos(node), sin(node), 0.0,\n\n\t\t\t\t- sin(node), cos(node), 0.0,\n\n\t\t\t\t0.0, 0.0, 1.0\n\n\t\t\t);\n\n//return coord;\n\n\t\t\treturn rotZ * rotX * coord;\n\n\t\t\t// return coord * rotX * rotZ;\n\n\n\n\t\t#else\n\n\n\n\t\t\treturn vec3(\n\n\t\t\t\tx, y, z\n\n\t\t\t);\n\n\n\n\t\t#endif\n\n\n\n\n\n\t\t// Get derivates for velocity\n\n\t\t// float vf = sqrt(GM * a) / r;\n\n\t\t// float vx = vf * - sin(E);\n\n\t\t// float vy = vf * sqrt(1.0 - e*e) * cos(E);\n\n\t\t// Calculate velocity\n\n\t\t// return vec3(\n\n\t\t// \t+ vx * FxX - vy * FxY,\n\n\t\t// \t+ vx * FyX + vy * FyY,\n\n\t\t// \t+ vx * FzX + vy * FzY,\n\n\t\t// );\n\n\n\n\t}\n\n\n\n#endif\n\n\n\n// ***************************************************************\n\n// ***************************************************************\n\n\n\nvoid main()\n\n{\n\n\n\n\t// attenuate the more away from current position\n\n\t// fragColor = vec4(color, 0.35 - 0.275 * pow(abs(position), .1));\n\n\n\n    fragColor = vec4(color, 1.0); // vec4(color, (1.0 - position) * 0.75 + 0.25);\n\n\n\n\t// attenuate the orbit to create a trail (position is linear from 0 to 1)\n\n\tfragColor.a *= (pow(exp(-position * attenuate), 2.0)) * lucency;\n\n\n\n    float foo = 1.0 + smoothstep(0.9, 1.0, position) * (step(attenuate, 0.0) - 1.0);\n\n\n\n    fragColor.a *= foo;\n\n\n\n    //fragColor.a *= (1.0 - position);\n\n\n\n\t// calculate the actual position\n\n\tvec3 pos = orb2cart((position * trailLength) * PI2 + (trailStart) * PI2,\n\n\t\tl_orbitals[0], l_orbitals[1], l_orbitals[2],\n\n\t\th_orbitals[0], h_orbitals[1], h_orbitals[2]\n\n\t);\n\n\n\n\t// calculate the final world position to be drawn\n\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n\n\n\n\t// THREE.ShaderChunk[ 'logdepthbuf_vertex'\n\n\t#include <logdepthbuf_vertex>\n\n\n\n}\n\n\n\n// ***************************************************************\n\n// ***************************************************************\n\n\n\n\n\n        ";
this.fragmentShader="\n\n        #define varying in\n\n        out highp vec4 pc_fragColor;\n\n        #define gl_FragColor pc_fragColor\n\n        #define gl_FragDepthEXT gl_FragDepth\n\n\n\n        // ***************************************************************\n\n        // orbit.frag\n\n        // ***************************************************************\n\n        precision highp float;\n\n        precision highp int;\n\n        #include <common>\n\n        #include <logdepthbuf_pars_fragment>\n\n        \n\n        uniform float lucency;\n\n        varying vec4 fragColor;\n\n        \n\n        // ***************************************************************\n\n        // ***************************************************************\n\n\n\n        void main()\n\n        {\n\n\n\n            // passed from vertex shader\n\n            gl_FragColor = fragColor;\n\n        \n\n            // we use translucency, since this is less error prone\n\n            // in case you forgot to define opacity (default is 0)\n\n            // gl_FragColor.a *= 1.0 - lucency;\n\n        \n\n            // gl_FragColor.a = max(gl_FragColor.a, 0.3);\n\n            // gl_FragColor.r += 0.2;\n\n            \n\n        \n\n            // THREE.ShaderChunk[ 'logdepthbuf_fragment' ]\n\n            #include <logdepthbuf_fragment>\n\n\n\n        }\n\n        \n\n        // ***************************************************************\n\n        // ***************************************************************\n\n        \n\n        "}addOrbital(c){}addUniforms(c){super.addUniforms(c)}updateUniforms(){super.updateUniforms()}getVertexChunks(){var c=
super.getVertexChunks();c.push({after:/<common>/,shader:[]});c.push({before:/<begin_vertex>/,shader:[]});return c}getFragmentChunks(){var c=super.getFragmentChunks();c.push({after:/<common>/,shader:[]});c.push({before:/<aomap_fragment>/,shader:[]});c.push({after:/<aomap_fragment>/,shader:[]});c.push({after:/vec3 outgoingLight/,shader:[]});return c}}g.prototype.lucency=null;g.prototype.attenuate=null;g.prototype.trailLength=null;g.prototype.trailStart=null;g.prototype.trailEnd=null;e.OrbitalsShader=
g})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});THRAPP.BaseMaterial=THRAPP.BaseMaterial||THRAPP.CustomMeshPhysicalMaterial;
(function(h,e){var g=new h.Matrix4;class c extends e.BaseMaterial{constructor(a){super(a);this.setDefines({NUM_STARS:0,NUM_ECLIPSERS:0});this.stars=[];this.eclipsers=[];this.addStar(a.stars||[]);this.addEclipser(a.eclipsers||[]);this.uniforms.bodyRadius.value=a.radius||0;null!=a.laserSize&&(this.defines.USE_ECLIPSE_LASER="",this.uniforms.laserSize.value=a.laserSize);this.pbody=a.pbody||null}addStar(a){Array.isArray(a)||(a=[a]);for(var b=0;b<a.length;b++)this.stars.push(a[b]),this.uniforms.lightPos.value.push(new h.Vector3),
this.uniforms.lightSize.value.push(2*(a[b].radius||0));this.defines.NUM_STARS!=this.stars.length&&(this.defines.NUM_STARS=this.stars.length,this.needsUpdate=!0)}addEclipser(a){Array.isArray(a)||(a=[a]);for(let b=0;b<a.length;b++)this.eclipsers.push(a[b]),this.uniforms.eclipserPos.value.push(new h.Vector3),this.uniforms.eclipserSize.value.push(2*(a[b].radius||0));this.defines.NUM_ECLIPSERS!=this.eclipsers.length&&(this.defines.NUM_ECLIPSERS=this.eclipsers.length,this.needsUpdate=!0)}addUniforms(a){super.addUniforms(a);
a.eclipserSize={type:"fv1",value:[]};a.eclipserPos={type:"v3v",value:[]};a.lightSize={type:"fv1",value:[]};a.lightPos={type:"v3v",value:[]};a.laserSize={type:"f",value:5E-7};a.bodyRadius={type:"f",value:5E-7}}updateUniforms(){var a=this.uniforms,b=this.eclipsers,d=this.stars;super.updateUniforms();this.pbody&&(this.pbody.updateMatrix(),g.copy(this.pbody.matrixWorld).invert());for(var f=0;f<b.length;f+=1)a.eclipserPos.value[f].setFromMatrixPosition(b[f].matrixWorld),a.eclipserPos.value[f].applyMatrix4(g);
for(f=0;f<d.length;f+=1)a.lightPos.value[f].setFromMatrixPosition(d[f].matrixWorld),a.lightPos.value[f].applyMatrix4(g)}debug(a,b){var d=new h.Vector3,f=this.uniforms.lightPos.value,m=this.uniforms.lightSize.value,q=this.uniforms.eclipserPos.value,x=this.uniforms.eclipserSize.value,y=this.uniforms.bodyRadius.value;console.log("Body Radius: ",y);console.log("Light[",a,"] - size: ",m[a],", pos: ",f[a]);console.log("Eclipser[",b,"] - size: ",x[b],", pos: ",q[b]);d=d.copy(f[a]).sub(q[b]).length();q=q[b].length()-
y;a=m[a]/d*q;console.log("Umbra(outer): ",x[b]/d*(d+q)-a,", Penumbra(core): ",a)}getVertexChunks(){var a=super.getVertexChunks();a.push({after:/<common>/,shader:["  // Local vertex position","  varying vec3 vertexPos;"]});a.push({before:/<begin_vertex>/,shader:[" // Pass vertex position to fragments","  vertexPos = position;"]});return a}getFragmentChunks(){var a=super.getFragmentChunks();a.push({after:/<common>/,shader:"  uniform float bodyRadius;,#ifdef USE_ECLIPSE_LASER,  uniform float laserSize;,#endif,#if NUM_STARS > 0,  uniform vec3 lightPos[NUM_STARS];,  uniform float lightSize[NUM_STARS];,#endif,#if NUM_ECLIPSERS > 0,  uniform vec3 eclipserPos[NUM_ECLIPSERS];,  uniform float eclipserSize[NUM_ECLIPSERS];,#endif,  // Local vertex position,  varying vec3 vertexPos;,  // Scale from local to world,  varying vec3 localScale;,  // Rotate from local to world,  // Rotate and scale to world,  varying mat4 localRotScale;,  // Translate back to local space,  varying mat4 modelMatrixInverse;".split(",")});
a.push({after:/<common>/,shader:["  float lineDistToPoint(vec3 A, vec3 B, vec3 P) {","    // represent the line segment AB as a vector.","    vec3 AB = B - A;","    // determine the direction of B relative to A.","    vec3 AB_dir = normalize( AB );","    // compute the distance between A and Q using the dot","    // product trick.  The first argument is a unit length","    // vector.  The second argument is a point *relative to","    // that vector*.","    float AQ_len = dot( AB_dir, P - A );","    // Now that we know the length of AQ, we can compute Q.",
"    // To do this, think of the following equation as start","    // at A; move along the direction AB_dir by AQ_len units;","    // that position is Q.","    vec3 Q = A + AQ_len * AB_dir;","    // return the length of PQ.","    return length( Q - P );","  }"]});a.push({before:/<aomap_fragment>/,shader:["float shadows = 1.0;"]});a.push({after:/<aomap_fragment>/,shader:["#if NUM_STARS > 0 && NUM_ECLIPSERS > 0","  float starIntensity[NUM_STARS];","  #ifdef USE_ECLIPSE_LASER","    vec3 laserDot = vec3(0.0, 0.0, 0.0);",
"    vec3 laserCol = vec3(1.0, 0.0, 0.0);","  #endif",e.StartStaticForLoop("n","NUM_ECLIPSERS"),e.StartStaticForLoop("i","NUM_STARS"),"      // Get light position from passed uniform. There seems to be other way","      // to get these via `pointLings[n].position`, but unsure how exactly.","      // Get closest distance from the vertex point to the light ray.","      // We want to do this calculation in world space, but for best accuracy","      // we need to get the vertex point into local space. We simply do that",
"      // by translating all points into local space by subtracting the world","      // position of the parent system (moving zero coordinate). Which would be:","      // float dist = lineDistToPoint(eclipserPos[n], lightPos[i], vertexWorldPos - off);","      // The last subtraction is problematic, as it looses a lot of precision.","      // Instead we provide a uniform with world position of the parent frame.","      // This probably ignores some scaling and maybe some rotations, but allows","      // us to do the subtraction on values that are themselves rather big.",
"      // vec3 light = (vec4(pointLights[ i ].position, 1.0) * viewMatrix).xyz;","      float behind = step(0.0, length(vertexPos - lightPos[i]) - length(lightPos[i]));","      float dist = lineDistToPoint(eclipserPos[n], lightPos[i], vertexPos) + behind * 9e32;","      // inner umbra and quadratic falloff for outer penumbra","      // calculate umbra and penumbra from radii and distances","      // http://www.opticiansfriend.com/articles/equations.html#Shadows","      // Length from light source to L1 & Length from L1 to Umbra",
"      float L1 = length(lightPos[i] - eclipserPos[n]);","      float L2 = length(eclipserPos[n]) - bodyRadius;","      float D1 = lightSize[i];","      float D2 = eclipserSize[n];","      float P = D1 / L1 * L2;","      float U = D2 / L1 * (L1 + L2) - P;","      U = max(U, 0.0); P = max(P, U);","      starIntensity[i] += pow(smoothstep(U*.97, P, dist), 0.5);","      #ifdef USE_ECLIPSE_LASER","        laserDot += smoothstep(laserSize, laserSize*.2, dist) * laserCol;","      #endif",e.EndStaticForLoop("i",
"NUM_STARS"),e.EndStaticForLoop("n","NUM_ECLIPSERS"),"  float globalIntensity = 0.0;",e.StartStaticForLoop("m","NUM_STARS"),"    starIntensity[m] /= float(NUM_ECLIPSERS);","    globalIntensity += starIntensity[m] / float(NUM_STARS);",e.EndStaticForLoop("m","NUM_STARS"),"  shadows *= pow(clamp(globalIntensity, 0.0, 1.0), 2.0);","#endif"]});a.push({after:/vec3 outgoingLight/,shader:"outgoingLight *= clamp(0.0, 1.0, shadows);{#if NUM_STARS > 0 && NUM_ECLIPSERS > 0{  #ifdef USE_ECLIPSE_LASER{    outgoingLight = clamp(outgoingLight + laserDot, 0.0, 1.0);{  #endif{#endif".split("{")});
return a}}c.prototype.pbody=null;c.prototype.radius=null;c.prototype.stars=null;c.prototype.eclipsers=null;c.prototype.laserSize=null;e.EclipseShader=c})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){var g=new h.Matrix4;class c extends e.EclipseShader{constructor(a){super(a);this.setDefines({NUM_RINGS:0});this.rings=[];this.addRing(a.rings||[]);a.nightMap&&(this.defines.USE_UV="",this.defines.USE_NIGHT_MAP="",this.uniforms.nightMap.value=a.nightMap);a.ringMap&&(this.defines.USE_RING_MAP="",this.uniforms.ringMap.value=a.ringMap)}addRing(a){Array.isArray(a)||(a=[a]);for(var b=0;b<a.length;b++){this.rings.push(a[b]);var d=new h.Vector2(a[b].innerRadius||0,a[b].outerRadius||0);this.uniforms.ringRadii.value.push(d);
this.uniforms.ringNorm.value.push(new h.Vector3);this.uniforms.ringWMat4.value.push(a[b].matrixWorld||new h.Matrix4)}this.defines.NUM_RINGS+=a.length;this.needsUpdate=!0}updateUniforms(){var a=this.rings,b=this.uniforms;super.updateUniforms();this.pbody&&g.copy(this.pbody.matrixWorld).invert();for(var d=0;d<a.length;d+=1)b.ringNorm.value[d].set(0,0,1).applyMatrix4(a[d].matrixWorld).applyMatrix4(g)}addUniforms(a){super.addUniforms(a);a.nightMap={type:"t",value:null};a.ringMap={type:"t",value:null};
a.ringWMat4={type:"vm4",value:[]};a.ringNorm={type:"v3v",value:[]};a.ringRadii={type:"v2v",value:[]}}getVertexChunks(){return super.getVertexChunks()}getFragmentChunks(){var a=super.getFragmentChunks();a.push({after:/<common>/,shader:["#ifdef USE_NIGHT_MAP","  uniform sampler2D nightMap;","#endif"]});a.push({after:/vec3 outgoingLight/,shader:["#ifdef USE_NIGHT_MAP","  float hasLight = 0.0;",e.StartStaticForLoop("i","NUM_STARS"),"    float girrad = dot(-normalize(vertexPos), normalize(lightPos[i]));",
"    hasLight += pow(1.0 - clamp(girrad, 0.0, 1.0), 4.0);","#ifdef DEBUG_DAYLIGHT_TERMINATOR","    if (girrad < 0.01 && girrad > 0.0) outgoingLight.r = 1.0; ","#endif",e.EndStaticForLoop("i","NUM_STARS"),"  outgoingLight += texture2D(nightMap, vUv).xyz * clamp(1.0 - hasLight, 0.0, 1.0);","#else","#endif"]});a.push({after:/<common>/,shader:"#ifdef USE_RING_MAP,  uniform sampler2D ringMap;,#endif,#if NUM_RINGS > 0,  uniform vec2 ringRadii[NUM_RINGS];,  uniform mat4 ringWMat4[NUM_RINGS];,  uniform vec3 ringNorm[NUM_RINGS];,#endif".split(",")});
a.push({after:/<aomap_fragment>/,shader:["float ringShadows = 1.0;","#if NUM_RINGS > 0 && NUM_STARS > 0","  float ringShadow[NUM_STARS];",e.StartStaticForLoop("n","NUM_RINGS"),"    vec3 axisWorldDir = normalize(ringNorm[n]);","    ringShadow[n] = 0.0;",e.StartStaticForLoop("i","NUM_STARS"),"      // Intersect the vertex point with the ring plane and return distance to center.","      // From there we can calculate if it lies between inner and outer radius.","      float d = dot(-vertexPos, axisWorldDir) / dot(lightPos[i], axisWorldDir);",
"      vec3 p = vertexPos + lightPos[i] * d;","      // Check if distance is between inner and outer radius","      float range = (ringRadii[n].y - ringRadii[n].x) / 2.0;","      float dist = abs(length(p) - ringRadii[n].x - range);","      float fact = 1.0 - clamp(pow(dist / range, 8.0), 0.0, 1.0);","      fact *= step(0.0, d);","#ifdef USE_RING_MAP","        vec2 rUv = vec2(0.5, 1.0 - (length(p) - ringRadii[n].x) / range / 2.0);","        vec4 tex = texture2D(ringMap, rUv);","        // Calculate luminance at the texture position",
"        float lum = 0.2126*tex.r + 0.7152*tex.g + 0.0722*tex.b;","        ringShadow[n] += fact * pow(lum, 0.5) * pow(tex.a, 0.5);","#else","        ringShadow[n] += fact;","#endif",e.EndStaticForLoop("i","NUM_STARS"),e.EndStaticForLoop("n","NUM_RINGS"),e.StartStaticForLoop("i","NUM_RINGS"),"    ringShadows -= ringShadow[i] / float(NUM_STARS);",e.EndStaticForLoop("i","NUM_RINGS"),"  shadows *= ringShadows;","#endif"]});return a}}c.prototype.nightMap=null;c.prototype.ringMap=null;e.PlanetShader=c})(THREE,
THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){var g=new h.Matrix4;class c extends e.PlanetShader{constructor(a){super(a);this.setDefines({USE_GROUNDSHADER:1,NUM_SAMPLES:16});if(a.atmosphere){a=a.atmosphere;var b=this.uniforms;a.G=a.G||-.95;a.Kr=a.Kr||.0025;a.Km=a.Km||.001;a.ESun=a.ESun||20;a.bias=a.bias||.5;a.skale=a.skale||.5;a.exposure=a.exposure||2.5;a.scaleDepth=a.scaleDepth||.25;a.scaleHeight=a.scaleHeight||1.025;a.innerRadius=a.innerRadius||r*KM2AU;var d=a.wavelength;b.v3InvWavelength.value.set(1/Math.pow(d.x,4),1/Math.pow(d.y,
4),1/Math.pow(d.z,4));d=a.G;b.fg.value=d;b.fg2.value=d*d;d=a.Kr;var f=a.Km,m=a.ESun;b.fKrESun.value=d*m;b.fKmESun.value=f*m;b.fKr4PI.value=4*d*Math.PI;b.fKm4PI.value=4*f*Math.PI;d=a.scaleDepth;f=a.innerRadius;m=f+a.height;b.fBias.value=a.bias;b.fExposure.value=a.exposure;b.fScale.value=1/(m-f);b.fScaleDepth.value=d;b.fOuterRadius.value=m;b.fInnerRadius.value=f;b.fOuterRadius2.value=m*m;b.fInnerRadius2.value=f*f}}updateUniforms(){var a=this.uniforms;super.updateUniforms();var b=a.fCameraPos.value;
b.setFromMatrixPosition(camera.matrixWorld);g.copy(this.pbody.matrixWorld).invert();b.applyMatrix4(g);b=b.lengthSq();a.fCameraHeight.value=Math.sqrt(b);a.fCameraHeight2.value=b}addUniforms(a){super.addUniforms(a);a.fg={type:"f",value:0};a.fg2={type:"f",value:0};a.fKrESun={type:"f",value:0};a.fKmESun={type:"f",value:0};a.fKr4PI={type:"f",value:0};a.fKm4PI={type:"f",value:0};a.fScale={type:"f",value:0};a.fBias={type:"f",value:0};a.fExposure={type:"f",value:0};a.fScaleDepth={type:"f",value:0};a.fOuterRadius=
{type:"f",value:0};a.fInnerRadius={type:"f",value:0};a.fOuterRadius2={type:"f",value:0};a.fInnerRadius2={type:"f",value:0};a.fCameraHeight={type:"f",value:0};a.fCameraHeight2={type:"f",value:0};a.v3InvWavelength={type:"v3",value:new h.Vector3};a.fCameraPos={type:"v3",value:new h.Vector3}}getVertexChunks(){var a=super.getVertexChunks();a.push({after:/<common>/,shader:["#if USE_GROUNDSHADER > 0 && NUM_STARS > 0","  uniform vec3 lightPos[NUM_STARS];","  uniform float lightSize[NUM_STARS];","  uniform vec3 fCameraPos;       // The Camera Position",
"  uniform vec3 v3InvWavelength;   // 1 / pow(abs(wavelength), 4) for the red, green, and blue channels","  uniform float fCameraHeight;    // The cameras current height","  uniform float fCameraHeight2;   // fCameraHeight^2","  uniform float fOuterRadius;     // The outer (atmosphere) radius","  uniform float fOuterRadius2;    // fOuterRadius^2","  uniform float fInnerRadius;     // The inner (planetary) radius","  uniform float fInnerRadius2;    // fInnerRadius^2","  uniform float fKrESun;          // Kr * ESun",
"  uniform float fKmESun;          // Km * ESun","  uniform float fKr4PI;           // Kr * 4 * PI","  uniform float fKm4PI;           // Km * 4 * PI","  uniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)","  uniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmospheres average density is found)","  uniform float fBias;            // GroundShader Bias","  varying vec3 v3RayleighColor;","  varying vec3 v3MieColor;","  float scale(float fCos)","  {",
"  \tfloat x = 1.0 - fCos;","  \treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));","  }","#endif"]});a.push({after:/<begin_vertex>/,shader:["#if USE_GROUNDSHADER > 0 && NUM_STARS > 0","  v3RayleighColor *= 0.0;","  v3MieColor *= 0.0;","  float fInvScaleDepth = (1.0 / fScaleDepth);","  float fScaleOverScaleDepth = fScale / fScaleDepth;","  // Do all the calculation in local space, since this yields best precision","  vec3 cameraLocal = fCameraPos; // vec3(modelMatrixInverse * vec4(cameraPosition, 1.0));",
"  // Get the ray from the camera to the vertex and its length","  // which is the far point of the ray passing through the atmosphere","  vec3 v3Ray = position - cameraLocal;","  float fFar = length(v3Ray);","  v3Ray /= fFar;","  // Calculate the closest intersection of the ray with the outer atmosphere","  // Which is the near point of the ray passing through the atmosphere","  float B = 2.0 * dot(cameraLocal, v3Ray);","  float C = fCameraHeight2 - fOuterRadius2;","  float fDet = max(0.0, B*B - 4.0 * C);",
"  float fNear = 0.5 * (-B - sqrt(fDet));","  float fDepth = exp((fInnerRadius - fOuterRadius) * fScaleOverScaleDepth);","  float fCameraAngle = dot(-v3Ray, position) / length(position);","  float fCameraScale = scale(fCameraAngle);","  float fCameraOffset = fDepth*fCameraScale;",e.StartStaticForLoop("n","NUM_STARS"),"    // Do all the calculation in local space, since this yields best precision","    vec3 lightLocal = lightPos[n]; // vec3(modelMatrixInverse * vec4(starPos[n], 1.0));","    // Calculate the ray's starting position, then calculate its scattering offset",
"    vec3 v3Start = cameraLocal + v3Ray * fNear;","    fFar -= fNear;","    float fLightAngle = dot(lightLocal, position) / length(position);","    float fLightScale = scale(fLightAngle);","    float fTemp = (fLightScale + fCameraScale);","    // Initialize the scattering loop variables","    float fSampleLength = fFar / float(NUM_SAMPLES);","    float fScaledLength = fSampleLength * fScale;","    vec3 v3SampleRay = v3Ray * fSampleLength;","    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;","    // Now loop through the sample rays",
"    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);","    vec3 v3Attenuate;","    for(int i=0; i<NUM_SAMPLES; i++)","    {","        float fHeight = length(v3SamplePoint);","        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));","        float fScatter = fDepth*fTemp - fCameraOffset;","        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));","        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);","        v3SamplePoint += v3SampleRay;","    }","    v3RayleighColor += v3FrontColor * (v3InvWavelength * fKrESun + fKmESun) / float(NUM_STARS);",
"    v3MieColor += v3Attenuate / float(NUM_STARS);",e.EndStaticForLoop("n","NUM_STARS"),"#endif"]});return a}getFragmentChunks(){var a=super.getFragmentChunks();a.push({after:/<common>/,shader:["#if USE_GROUNDSHADER > 0 && NUM_STARS > 0","  varying vec3 v3RayleighColor;","  varying vec3 v3MieColor;","  uniform float fBias;","#endif"]});a.push({after:/vec3 outgoingLight/,shader:["#if USE_GROUNDSHADER > 0 && NUM_STARS > 0","  vec3 color = v3RayleighColor + 0.25 * v3MieColor;","  outgoingLight = mix(outgoingLight, color, fBias);",
"#endif"]});return a}}c.prototype.atmosphere=null;e.GroundShader=c})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){var g=new h.Matrix4;class c extends e.CustomMaterial(h.ShaderMaterial,"ShaderMaterial","basic"){constructor(a){super(a);this.setDefines({NUM_STARS:0,USE_ATMOSPHERE:""});if(a.atmosphere){var b=a.atmosphere,d=this.uniforms;b.G=b.G||-.95;b.Kr=b.Kr||.0025;b.Km=b.Km||.001;b.ESun=b.ESun||20;b.bias=b.bias||.5;b.skale=b.skale||.5;b.exposure=b.exposure||2.5;b.scaleDepth=b.scaleDepth||.25;b.scaleHeight=b.scaleHeight||1.025;b.innerRadius=b.innerRadius||r*KM2AU;var f=b.wavelength;d.v3InvWavelength.value.set(1/
Math.pow(f.x,4),1/Math.pow(f.y,4),1/Math.pow(f.z,4));f=b.G;d.fg.value=f;d.fg2.value=f*f;f=b.Kr;var m=b.Km,q=b.ESun;d.fKrESun.value=f*q;d.fKmESun.value=m*q;d.fKr4PI.value=4*f*Math.PI;d.fKm4PI.value=4*m*Math.PI;f=b.scaleDepth;m=b.innerRadius;q=m+b.height;d.fBias.value=b.bias;d.fExposure.value=b.exposure;d.fScale.value=1/(q-m);d.fScaleDepth.value=f;d.fOuterRadius.value=q;d.fInnerRadius.value=m;d.fOuterRadius2.value=q*q;d.fInnerRadius2.value=m*m}this.stars=[];this.addStar(a.stars||[])}addStar(a){Array.isArray(a)||
(a=[a]);for(var b=0;b<a.length;b++)this.stars.push(a[b]),this.uniforms.lightPos.value.push(new h.Vector3),this.uniforms.lightSize.value.push(2*(a[b].radius||0));this.defines.NUM_STARS+=a.length;this.needsUpdate=!0}updateUniforms(){var a=this.uniforms,b=this.stars,d=a.v3LightPos.value,f=a.v3CameraPos.value;f.setFromMatrixPosition(camera.matrixWorld);d.setFromMatrixPosition(light.matrixWorld);this.pbody&&this.pbody.matrixWorld&&(g.copy(this.pbody.matrixWorld).invert(),d.applyMatrix4(g),f.applyMatrix4(g));
d=f.lengthSq();a.fCameraHeight.value=Math.sqrt(d);a.fCameraHeight2.value=d;for(d=0;d<b.length;d+=1)b[d].getWorldPosition(a.lightPos.value[d]),a.lightPos.value[d].applyMatrix4(g)}addUniforms(a){super.addUniforms(a);a.fg={type:"f",value:0};a.fg2={type:"f",value:0};a.fKrESun={type:"f",value:0};a.fKmESun={type:"f",value:0};a.fKr4PI={type:"f",value:0};a.fKm4PI={type:"f",value:0};a.fScale={type:"f",value:0};a.fBias={type:"f",value:0};a.fExposure={type:"f",value:0};a.fScaleDepth={type:"f",value:0};a.fOuterRadius=
{type:"f",value:0};a.fInnerRadius={type:"f",value:0};a.fOuterRadius2={type:"f",value:0};a.fInnerRadius2={type:"f",value:0};a.fCameraHeight={type:"f",value:0};a.fCameraHeight2={type:"f",value:0};a.v3InvWavelength={type:"v3",value:new h.Vector3};a.v3CameraPos={type:"v3",value:new h.Vector3};a.v3LightPos={type:"v3",value:new h.Vector3};a.lightSize={type:"fv1",value:[]};a.lightPos={type:"v3v",value:[]}}getVertexChunks(){var a=super.getVertexChunks();a.push({after:/<common>/,shader:["#if NUM_STARS > 0",
"  uniform vec3 lightPos[NUM_STARS];","  uniform float lightSize[NUM_STARS];","#endif","// These must be passed in local object space","  uniform vec3 v3LightPos;        // The Light Position","  uniform vec3 v3CameraPos;       // The Camera Position","  uniform vec3 v3InvWavelength;   // 1 / pow(abs(wavelength), 4) for the red, green, and blue channels","  uniform float fCameraHeight;    // The cameras current height","  uniform float fCameraHeight2;   // fCameraHeight^2","  uniform float fOuterRadius;     // The outer (atmosphere) radius",
"  uniform float fOuterRadius2;    // fOuterRadius^2","  uniform float fInnerRadius;     // The inner (planetary) radius","  uniform float fInnerRadius2;    // fInnerRadius^2","  uniform float fKrESun;          // Kr * ESun","  uniform float fKmESun;          // Km * ESun","  uniform float fKr4PI;           // Kr * 4 * PI","  uniform float fKm4PI;           // Km * 4 * PI","  uniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)","  uniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmospheres average density is found)",
"  uniform float fBias;            // GroundShader Bias","  varying vec3 v3Direction;","  varying vec3 v3RayleighColor;","  varying vec3 v3MieColor;","  varying float fMiePhase;","  uniform float fg;","  uniform float fg2;","  const int nSamples = 16;","  const float fSamples = float(nSamples); // or 1.125","  float scale(float fCos)","  {","  \tfloat x = 1.0 - fCos;","  \treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));","  }"]});a.push({after:/<begin_vertex>/,shader:["  // vec3 v3CameraPos = cameraPosition; // vec3(1.5, 0.5, 10.0);",
"  float fCameraHeight = length(v3CameraPos);","  float fCameraHeight2 = fCameraHeight * fCameraHeight;","  float fInvScaleDepth = (1.0 / fScaleDepth);","  float fScaleOverScaleDepth = fScale / fScaleDepth;","  // Do all the calculation in local space, since this yields best precision","  vec3 cameraLocal = v3CameraPos; // vec3(modelMatrixInverse * vec4(cameraPosition, 1.0));","  // Get the ray from the camera to the vertex and its length","  // which is the far point of the ray passing through the atmosphere",
"  vec3 v3Pos = position; //","  vec3 v3Ray = position - cameraLocal;","  float fFar = length(v3Ray);","  v3Ray /= fFar;","  // Pass direction to fragment shader","  v3Direction = v3CameraPos - v3Pos;","  // Calculate the closest intersection of the ray with the outer atmosphere","  // Which is the near point of the ray passing through the atmosphere","  float B = 2.0 * dot(v3CameraPos, v3Ray);","  float C = fCameraHeight2 - fOuterRadius2;","  float fDet = max(0.0, B*B - 4.0 * C);","  float fNear = 0.5 * (-B - sqrt(fDet));",
"  // Calculate the ray's starting position, then calculate its scattering offset","  vec3 v3Start = v3CameraPos + v3Ray * fNear;","  fFar -= fNear;","  float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;","  float fStartDepth = exp(-1.0 / fScaleDepth);","  float fStartOffset = fStartDepth*scale(fStartAngle);","  // Initialize the scattering loop variables","  float fSampleLength = fFar / fSamples;","  float fScaledLength = fSampleLength * fScale;","  vec3 v3SampleRay = v3Ray * fSampleLength;",
"  vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;","  // Now loop through the sample rays","  vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);","  for(int i=0; i<nSamples; i++)","  {","    float fHeight = length(v3SamplePoint);","    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));","    float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;",e.StartStaticForLoop("n","NUM_STARS"),"        float fLightAngle = dot(lightPos[n], v3SamplePoint) / fHeight;","        float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));",
"        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));","        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);","        v3SamplePoint += v3SampleRay;",e.EndStaticForLoop("n","NUM_STARS"),"  }","  v3RayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);","  v3MieColor = v3FrontColor * fKmESun;;","vec3 lightPos = lightPos[0];","lightPos *= 0.95;","float fCos = dot(lightPos, v3Direction) / length(v3Direction);","fMiePhase = 1.5 * ((1.0 - fg2) / (2.0 + fg2)) * (1.0 + fCos*fCos) / pow(1.0 + fg2 - 2.0*fg*fCos, 1.5);"]});
return a}getFragmentChunks(){var a=super.getFragmentChunks();a.unshift({after:/<common>/,shader:"#if NUM_STARS > 0,  uniform vec3 lightPos[NUM_STARS];,  uniform float lightSize[NUM_STARS];,#endif,#ifdef USE_ATMOSPHERE,  uniform float fg;,  uniform float fg2;,  uniform vec3 v3LightPos;,  varying vec3 v3RayleighColor;,  varying vec3 v3MieColor;,  varying vec3 v3Direction;,  varying float fMiePhase;,  uniform float fExposure;,  uniform float fBias;,#endif".split(",")});a.push({after:/vec3 outgoingLight/,
shader:["outgoingLight = v3RayleighColor + fMiePhase * v3MieColor;","outgoingLight = vec3(1.0, 1.0, 1.0) - exp(-fExposure * outgoingLight);","float lum = 0.2126*outgoingLight.r + 0.7152*outgoingLight.g + 0.0722*outgoingLight.b;","diffuseColor.a = clamp(lum, 0.0, 1.0);"]});return a}}c.prototype.stars=null;c.prototype.atmosphere=null;e.SkyShader=c})(THREE,THRAPP);window.THRAPP||(window.THRAPP={});
(function(h,e){class g extends e.CustomMeshPhysicalMaterial{constructor(c){super(c);this.setDefines({NUM_ECLIPSERS:0});c.radius&&(this.uniforms.radius.value=c.radius);c.eclipsers&&(c=c.eclipsers,Array.isArray(c)||(c=[c]),this.defines.NUM_ECLIPSERS=c.length)}addUniforms(c){super.addUniforms(c);c.radius={type:"f",value:0}}getVertexChunks(){var c=super.getVertexChunks();c.unshift({after:/<common>/,shader:["  // The planetary radius","  uniform float radius;","  // Pass world space to fragments","  varying vec3 vertexPos;",
"  varying vec3 originPos;"]});c.unshift({after:/<begin_vertex>/,shader:["  // convert from local space to camera space","  vertexPos = vec3(modelViewMatrix * vec4(position, 1.0));","  originPos = vec3(modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0));"]});return c}getFragmentChunks(){var c=super.getFragmentChunks();c.unshift({after:/<common>/,shader:["  // The planetary radius","  uniform float radius;","  // Pass world space to fragments","  varying vec3 vertexPos;","  varying vec3 originPos;","  // Return distance between line AB and point P",
"  // Positive if intersection is behind the object.","  // Negative if intersection is in front of the object.","  float lineDistToPoint(vec3 A, vec3 B, vec3 P) {","    // represent the line segment AB as a vector.","    vec3 AB = B - A;","    // I am a bit worried about branch performance?","    // http://stackoverflow.com/a/4176288/1550314","    // if (length(B - P) > length(AB)) return 9e32;","    // calculate front step value to determine on which","    // side the shadow lies (only shade behind object).",
"    float front = step(0.0, length(B - P) - length(AB));","    // determine the direction of B relative to A.","    vec3 AB_dir = normalize( AB );","    // compute the distance between A and Q using the dot","    // product trick.  The first argument is a unit length","    // vector.  The second argument is a point *relative to","    // that vector*.","    float AQ_len = dot( AB_dir, P - A );","    // Now that we know the length of AQ, we can compute Q.","    // To do this, think of the following equation as start",
"    // at A; move along the direction AB_dir by AQ_len units;","    // that position is Q.","    vec3 Q = A + AQ_len * AB_dir;","    // return the length of PQ (negative if front).","    return length( Q - P ) * (-front * 2.0 + 1.0);","  }"]});c.unshift({after:/<aomap_fragment>/,shader:["  float shaded = 0.0;","#if NUM_POINT_LIGHTS > 0 && NUM_ECLIPSERS > 0",e.StartStaticForLoop("i","NUM_POINT_LIGHTS"),"    // Get camera position in eye/view coordinates","    vec3 light = pointLights[ i ].position;",
"    // Calculate distance from touch point from planet origin","    float dist = lineDistToPoint(vertexPos, light, originPos);","    shaded += 1.0 - clamp(pow(dist / radius, 64.0), 0.0, 1.0);",e.EndStaticForLoop("i","NUM_POINT_LIGHTS"),"#endif","#if NUM_POINT_LIGHTS > 1","  shaded /= float(NUM_POINT_LIGHTS);","#endif"]});c.unshift({after:/vec3 outgoingLight/,shader:["outgoingLight *= 1.0 - shaded;"]});return c}}g.prototype.radius=null;g.prototype.eclipsers=null;e.RingShader=g})(THREE,THRAPP);

/* crc: B08E36111B05FD706DFC2462F557135B */
